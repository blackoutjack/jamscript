--- ff-orig/mozilla-30.0/js/src/vm/Interpreter.cpp	2014-06-05 20:15:30.000000000 -0500
+++ ff-dev/mozilla-30.0/js/src/vm/Interpreter.cpp	2015-01-25 18:12:30.010776462 -0600
@@ -29,6 +29,11 @@
 #include "jsprf.h"
 #include "jsscript.h"
 #include "jsstr.h"
+#ifdef TxJS
+#include "jstransaction.h"
+#include "jsjam.h"
+#include "vm/ErrorObject.h"
+#endif
 #if JS_TRACE_LOGGING
 #include "TraceLogging.h"
 #endif
@@ -299,9 +304,39 @@
 
     Shape *shape = nullptr;
     JSObject *scope = nullptr, *pobj = nullptr;
+#ifdef TxJS
+    TxContext *tx = cx->getRunningTx();
+    if (tx) {
+        // %%% Don't really need to root these.
+        RootedPropertyName rootname(cx, name);
+        RootedObject rootobj(cx, obj);
+        RootedObject rootscope(cx, scope);
+        RootedObject rootpobj(cx, pobj);
+        if (tx->lookupName(cx, rootname, rootobj, &rootscope, &rootpobj, vp)) {
+            // Return the value previously assigned to the name.
+            return true;
+        }
+    }
+#endif
     if (LookupNameNoGC(cx, name, obj, &scope, &pobj, &shape)) {
+#ifdef TxJS
+        if (!FetchNameNoGC(pobj, shape, vp))
+            return false;
+        TxContext *tx = cx->getRunningTx();
+        if (tx) {
+            // Update the already-created read set node to reflect the value
+            // and the scope in which it was found.
+            //node->obj = pobj.get();
+            // Add the property to the read set, with the head of the scope
+            // chain as the object, and an undefined value.
+            // %%% Need to root?
+            tx->recordAction(cx, obj, NameToId(name), vp, AX_READ);
+        }
+        return true;
+#else
         if (FetchNameNoGC(pobj, shape, vp))
             return true;
+#endif
     }
 
     RootedObject objRoot(cx, obj), scopeRoot(cx), pobjRoot(cx);
@@ -442,8 +477,12 @@
     JS_ASSERT(args.length() <= ARGS_LENGTH_MAX);
     JS_ASSERT(!cx->compartment()->activeAnalysis);
 
+#ifdef TxJS
+    // %%% This assertion is being triggered nondeterministically.
+#else
     /* We should never enter a new script while cx->iterValue is live. */
     JS_ASSERT(cx->iterValue.isMagic(JS_NO_ITER_VALUE));
+#endif
 
     /* Perform GC if necessary on exit from the function. */
     AutoGCIfNeeded gcIfNeeded(cx);
@@ -626,6 +665,56 @@
 
     TypeScript::SetThis(cx, script, thisv);
 
+#ifdef TxJS
+    if (cx->mainThread().activation()) {
+        // Descend the stack to find the first dynamic introspector.
+        Value ispect = UndefinedValue();
+        StackFrame *prevfp = cx->interpreterFrame();
+        while (ispect.isUndefined()) {
+            ispect = prevfp->script()->getIntrospector();
+            prevfp = prevfp->prev();
+            if (!prevfp) break;
+        }
+
+        if (!ispect.isUndefined()) {
+#ifdef TxJS_TRANSPARENT
+            if (TxSubsumed(cx, ispect)) {
+                ispect = UndefinedValue();
+            } else {
+#endif
+                if (!BeginTx(cx, ispect))
+                    return false;
+                TxContext *tx = cx->getTxContext();
+
+                probes::StartExecution(script);
+                ExecuteState state(cx, script, thisv, scopeChainArg, type, evalInFrame, result);
+                bool ok = RunScript(cx, state);
+                probes::StopExecution(script);
+
+                if (!ok) {
+                    // Destroy the transaction in the error case.
+                    cx->setTxContext(tx->getNext());
+                    tx->finish(cx);
+                    js_free(tx);
+                    return false;
+                }
+
+                // Force non-inline execution.
+                int path = 1;
+                // Not used.
+                bool newType;
+                InterpreterActivation *act = cx->mainThread().activation()->asInterpreter();
+                if (!IntrospectTx(cx, tx, act, true, script, &path, &newType))
+                    return false;
+                JS_ASSERT(path == 1);
+                return true;
+#ifdef TxJS_TRANSPARENT
+            }
+#endif
+        }
+    }
+#endif
+
     probes::StartExecution(script);
     ExecuteState state(cx, script, thisv, scopeChainArg, type, evalInFrame, result);
     bool ok = RunScript(cx, state);
@@ -668,6 +757,516 @@
                          NullFramePtr() /* evalInFrame */, rval);
 }
 
+#ifdef TxJS
+bool
+js::BeginTx(JSContext *cx, const Value &tx_handler) {
+    // Throw exception if handler is not a function value.
+    if (!IsFunctionObject(tx_handler)) {
+        RootedValue rootIspect(cx, tx_handler);
+        ReportIsNotFunction(cx, rootIspect, NO_CONSTRUCT);
+        return false;
+    }
+
+    // Create the tx context and place it on top of the tx stack.
+    TxContext *tx = (TxContext*)js_malloc(sizeof(TxContext));
+    TxContext::initTx(cx, tx, tx_handler);
+    // TX_INIT -> TX_RUNNING
+    JS_ASSERT(tx->inState(TX_INIT));
+#ifdef TxJS_TRANSPARENT
+    // Noop if a transaction with the same handler function is active.
+    bool transparent = TxSubsumed(cx, tx_handler);
+    if (transparent) {
+        tx->setState(TX_DUMMY);
+    } else {
+#endif
+        tx->advanceState();
+#ifdef TxJS_TRANSPARENT
+    }
+#endif
+
+    tx = cx->setTxContext(tx);
+#ifdef TxJS_PROFILE_TX
+    js_jam_profileTxEntry(cx, tx);
+#endif
+
+    return true;
+}
+
+bool
+js::IntrospectTx(JSContext *cx, TxContext *tx, InterpreterActivation *activation, bool isEnd, HandleScript script, int *path, bool *newType) {
+    JS_ASSERT(tx->inState(TX_RUNNING));
+
+    InterpreterRegs &regs = activation->regs();
+
+    if (isEnd) {
+        // Short-circuit empty transactions.
+        if (tx->getSequenceSize() == 0) {
+            // Pop the current transaction context.
+            TxContext *doneTx = tx;
+            tx = cx->setTxContext(tx->getNext());
+
+            // Push the return value.
+            do { *regs.sp++ = doneTx->getReturnValue(); assertSameCompartmentDebugOnly(cx, regs.sp[-1]); } while (0);
+
+            doneTx->finish(cx);
+            js_free(doneTx);
+            
+            *path = 1;
+            return true;
+        }
+#ifdef TxJS_PROFILE_TX
+        js_jam_profileTxEnding(cx, tx);
+#endif
+#ifdef TxJS_PROFILE_ACTIONS
+        js_jam_profileActions(cx, tx);
+#endif
+        tx->setState(TX_ENDING);
+    } else {
+#ifdef TxJS_PROFILE_TX
+        js_jam_profileTxSuspension(cx, tx);
+#endif
+#ifdef TxJS_PROFILE_ACTIONS
+        js_jam_profileActions(cx, tx);
+#endif
+        tx->setState(TX_SUSPENDING);
+    }
+
+    Value tx_handler = tx->getHandler();
+    // BEGIN_TX should ensure this and throw an exception otherwise.
+    JS_ASSERT(IsFunctionObject(tx_handler));
+
+    RootedValue ispectv(cx, tx_handler);
+    cx->compartment()->wrap(cx, &ispectv);
+    // Push the handler value, mimicking PUSH_COPY.
+    do { *regs.sp++ = tx_handler; assertSameCompartmentDebugOnly(cx, regs.sp[-1]); } while (0);
+    // Push an undefined value, mimicking PUSH_UNDEFINED.
+    regs.sp++->setUndefined();
+
+    // With lazy class instantiation, the call to |js_NewTxObject| may
+    // trigger a clearing of the exception (for some reason). So we note
+    // it here and restore it afterwards.
+    bool restoreExc = cx->isExceptionPending();
+    RootedValue exc(cx);
+    if (restoreExc) {
+        if (!cx->getPendingException(&exc))
+            return false;
+    }
+    // Make a Tx object and push it as the arg, mimicking PUSH_OBJECT.
+    RootedObject txObj(cx, js_NewTxObject(cx, tx));
+    if (restoreExc) {
+        cx->setPendingException(exc);
+    }
+    do { regs.sp++->setObject(*txObj.get()); assertSameCompartmentDebugOnly(cx, regs.sp[-1]); } while (0);
+
+
+
+    // Invoke the handler function.
+
+    // TX_SUSPENDING|TX_ENDING -> TX_SUSPEND0|TX_END0
+    JS_ASSERT(tx->inState(TX_SUSPENDING | TX_ENDING));
+    tx->advanceState();
+
+    if (regs.fp()->hasPushedSPSFrame())
+        cx->runtime()->spsProfiler.updatePC(script, regs.pc);
+    JS_ASSERT(regs.stackDepth() >= 3);
+    CallArgs args = CallArgsFromSp(1, regs.sp);
+
+    RootedFunction fun(cx);
+    RootedScript funScript(cx);
+    bool isFunction = IsFunctionObject(args.calleev(), fun.address());
+
+    /*
+     * Some builtins are marked as clone-at-callsite to increase precision of
+     * TI and JITs.
+     */
+    if (isFunction && fun->isInterpreted()) {
+        funScript = fun->getOrCreateScript(cx);
+        if (!funScript)
+            return false;
+        if (cx->typeInferenceEnabled() && funScript->shouldCloneAtCallsite()) {
+            fun = CloneFunctionAtCallsite(cx, fun, script, regs.pc);
+            if (!fun)
+                return false;
+            args.setCallee(ObjectValue(*fun));
+        }
+    }
+
+    /* Don't bother trying to fast-path calls to scripted non-constructors. */
+    if (*path == 1 || !isFunction || !fun->isInterpretedConstructor()) {
+        if (!Invoke(cx, args))
+            return false;
+        Value *newsp = args.spAfterCall();
+        TypeScript::Monitor(cx, script, regs.pc, newsp[-1]);
+        regs.sp = newsp;
+            
+        if (tx->inState(TX_END0 | TX_SUSPEND0)) {
+            // This means that a native function was used as the 
+            // transaction handler, so execution doesn't go through
+            // JSOP_STOP. So we need to advance the transaction state
+            // twice.
+
+            // TX_END0|TX_SUSPEND0 -> TX_END1|TX_SUSPEND1
+            JS_ASSERT(tx->inState(TX_END0 | TX_SUSPEND0));
+            tx->advanceState();
+        }
+
+        if (tx->inState(TX_END1 | TX_SUSPEND1)) {
+            // TX_END1|TX_SUSPEND1 -> TX_DONE|TX_RESUME
+            JS_ASSERT(tx->inState(TX_END1 | TX_SUSPEND1));
+            tx->advanceState();
+        }
+
+        JS_ASSERT(tx->inState(TX_RESUME | TX_DONE));
+        if (tx->inState(TX_RESUME)) {
+            // This serves the purpose of both the |type| conditionals
+            // in JSOP_STOP in setting or suppressing the return value
+            // of the call.
+            if (tx->getSuspend()->type == AX_FORIN) {
+                // Pop the top value which is not used.
+                regs.sp--;
+                JS_ASSERT(regs.stackDepth() >= 1);
+                // Create the iterator.
+                uint8_t flags = GET_UINT8(regs.pc);
+                MutableHandleValue res = MutableHandleValue::fromMarkedLocation(&regs.sp[-1]);
+                if (!ValueToIterator(cx, flags, res))
+                    return false;
+                JS_ASSERT(!res.isPrimitive());
+            } else {
+                // Cases AX_READ, AX_CALL, AX_DELETE, AX_WRITE.
+                // Write the tx's return value to the stack.
+                JS_ASSERT(regs.stackDepth() >= 1);
+                regs.sp[-1] = tx->getReturnValue();
+            }
+
+            // TX_RESUME -> TX_RUNNING
+            tx->advanceState();
+        } else {
+            JS_ASSERT(tx->inState(TX_DONE));
+            // Pop the current transaction context.
+            TxContext *doneTx = tx;
+            tx = cx->setTxContext(tx->getNext());
+            doneTx->finish(cx);
+            js_free(doneTx);
+
+        }
+
+        *path = 1;
+        return true;
+    }
+
+    InitialFrameFlags initial = INITIAL_NONE;
+    *newType = cx->typeInferenceEnabled() && UseNewType(cx, script, regs.pc);
+
+    TypeMonitorCall(cx, args, false);
+
+    funScript = fun->nonLazyScript();
+    if (!activation->pushInlineFrame(args, funScript, initial))
+        return false;
+        
+    if (*newType)
+        regs.fp()->setUseNewType();
+
+    // Save a transaction that is in the process of suspending,
+    // so we can automatically resume when this frame returns.
+    JS_ASSERT(regs.fp()->suspendedTx() == NULL);
+    regs.fp()->setSuspendedTx(tx);
+
+    // TX_SUSPEND0|TX_END0 -> TX_SUSPEND1|TX_END1;
+    JS_ASSERT(tx->inState(TX_SUSPEND0 | TX_END0));
+    tx->advanceState();
+
+    *path = 2;
+    return true;
+}
+
+bool
+js::TxSubsumed(JSContext *cx, const Value &ispect)
+{
+    TxContext *curtx = cx->getRunningTx();
+    if (curtx != NULL) {
+        RootedObject ispectObj(cx, &ispect.toObject());
+        RootedValue subsumer(cx);
+        bool checkSubsume = JSObject::getProperty(cx, ispectObj, ispectObj, cx->names().subsumedBy, &subsumer);
+        while (curtx != NULL) {
+            Value curIspect = curtx->getHandler();
+            if (curIspect == ispect || (checkSubsume && curIspect == subsumer)) {
+                return true;
+            }
+            curtx = curtx->getNext();
+        }
+    }
+    return false;
+}
+
+bool
+js::SuspendCall(JSContext *cx, TxContext *tx, CallArgs &args, bool *construct)
+{
+    InterpreterRegs &regs = cx->interpreterRegs();
+
+    // Suspend transactions on native function calls.
+    Value calleev = args.calleev();
+    if (!calleev.isObject())
+        return false;
+
+    // Strip any proxy objects.
+    JSObject *callee = &calleev.toObject();
+    while (IsProxy(callee)) {
+        calleev = GetProxyPrivate(callee);
+        if (!calleev.isObject())
+            return false;
+        callee = &calleev.toObject();
+    }
+
+    JSFunction *fun = NULL;
+    if (IsSuspendingFunction(cx, calleev, &fun)) {
+        if (fun->isBoundFunction()) {
+            JSAutoByteString bytes;
+            AtomToPrintableString(cx, fun->atom(), &bytes);
+            fprintf(stderr, "Suspending on bound function: %s\n", bytes.ptr());
+        }
+        tx->recordSuspend(cx, &args, *construct);
+        return true;
+    } else if (fun && fun->isBoundFunction()) {
+        uint32_t argc = args.length();
+
+        // Unwind bound functions.
+        JSObject *funobj = fun->getBoundFunctionTarget();
+        Value funv = ObjectValue(*funobj);
+        Value recv = fun->getBoundFunctionThis();
+        uint32_t boundargc = fun->getBoundFunctionArgumentCount();
+        uint32_t newargc = boundargc + argc;
+
+        // Pop the arguments and temporarily save.
+        Value *tmpargs = NULL;
+        if (newargc > 0)
+            tmpargs = (Value*)js_malloc(newargc * sizeof(Value));
+        for (uint32_t i=0; i<boundargc; i++) {
+            tmpargs[i] = fun->getBoundFunctionArgument(i);
+        }
+        for (uint32_t i=0; i<argc; i++) {
+            // Go from last argument to first.
+            tmpargs[newargc - 1 - i] = regs.sp[-1];
+            regs.sp--;
+        }
+
+        // Pop the receiver (presumably undefined) and the function.
+        regs.sp -= 2;
+
+        // Push the function value.
+        *regs.sp++ = funv;
+        // Push the new receiver.
+        *regs.sp++ = recv;
+
+        // Move the the receiver and arguments down one place.
+        for (uint32_t i=0; i<newargc; i++) {
+            *regs.sp++ = tmpargs[i];
+        }
+        if (newargc > 0)
+            js_free(tmpargs);
+
+        // Now we can generate the new CallArgs.
+        args = CallArgsFromSp(newargc, regs.sp);
+        return SuspendCall(cx, tx, args, construct);
+    } else if (IsNativeFunction(calleev, js_fun_apply)) {
+
+        Value funv = args.thisv();
+        if (!funv.isObject())
+            return false;
+
+        // Refactor the stack to create a new
+        // CallArgs, and pass that to recordAction.
+        //fprintf(stderr, "Suspending due to apply\n");
+
+        // Hopefully this is 2: the receiver and
+        // the arguments array.
+        uint32_t argc = args.length();
+        if (argc == 0) {
+            // This is an error case.
+            return false;
+        }
+
+        uint32_t newargc;
+        bool isargs = false;
+        RootedObject aobj(cx);
+        if (argc > 1) {
+            isargs = args.array()[1].isMagic(JS_OPTIMIZED_ARGUMENTS);
+            if (isargs) {
+                // Conversion necessary if the second
+                // arg is the arguments object.
+                newargc = regs.fp()->numActualArgs();
+                JS_ASSERT(newargc <= ARGS_LENGTH_MAX);
+            } else {
+                aobj = &args.array()[1].toObject();
+                if (!GetLengthProperty(cx, aobj, &newargc)) {
+                    // %%% Should really go into the exception case.
+                    fprintf(stderr, "Error with GetLengthProperty in apply suspend case");
+                    return false;
+                }
+            }
+        } else {
+            newargc = 0;
+        }
+
+        // Remove the original arguments.        
+        for (uint32_t i=0; i<argc; i++) {
+            regs.sp--;
+        }
+
+        // Pop the original receiver and function.
+        regs.sp -= 2;
+        // Replace |newApply| with the function value.
+        *regs.sp++ = funv;
+        // Push the new receiver.
+        Value recv = args.array()[0];
+        *regs.sp++ = recv;
+             
+        // Push the appropriate number of undefined
+        // values so there is space for the arguments.
+        for (uint32_t i=0; i<newargc; i++) {
+            regs.sp++->setUndefined(); // PUSH_UNDEFINED();
+        }
+
+        // Fill the stack with the actual arguments.
+        if (newargc > 0) {
+            if (isargs) {
+                regs.fp()->unaliasedForEachActual(CopyTo(regs.sp - newargc));
+            } else {
+                if (!GetElements(cx, aobj, newargc, regs.sp - newargc)) {
+                    // %%% Should really go into the exception case.
+                    fprintf(stderr, "Error with GetElements in apply suspend case");
+                    return false;
+                }
+            }
+        }
+            
+        // Now we can generate the new CallArgs.
+        args = CallArgsFromSp(newargc, regs.sp);
+        return SuspendCall(cx, tx, args, construct);
+    } else if (IsNativeFunction(calleev, js_fun_call)) {
+        Value funv = args.thisv();
+        if (!funv.isObject())
+            return false;
+
+        // Refactor the stack to create a new
+        // CallArgs, and pass that to recordAction.
+
+        // Should be > 1: a receiver and 0 or more arguments.
+        uint32_t argc = args.length();
+        if (argc == 0)
+            return false;
+
+        uint32_t newargc = argc - 1;
+
+        // Pop the arguments and temporarily save.
+        Value *tmpargs = NULL;
+        if (newargc > 0)
+            tmpargs = (Value*)js_malloc(newargc * sizeof(Value));
+        for (uint32_t i=0; i<newargc; i++) {
+            // Go from last argument to first.
+            tmpargs[newargc - 1 - i] = regs.sp[-1];
+            regs.sp--;
+        }
+        // Save the new receiver also.
+        Value recv = regs.sp[-1];
+        // Pop the new receiver, the function (old receiver),
+        // and the |call| function.
+        regs.sp -= 3;
+
+        // Push the function value.
+        *regs.sp++ = funv;
+        // Push the new receiver.
+        *regs.sp++ = recv;
+
+        // Move the the receiver and arguments down one place.
+        for (uint32_t i=0; i<newargc; i++) {
+            *regs.sp++ = tmpargs[i];
+        }
+        if (newargc > 0)
+            js_free(tmpargs);
+            
+        // Now we can generate the new CallArgs.
+        args = CallArgsFromSp(newargc, regs.sp);
+        return SuspendCall(cx, tx, args, construct);
+    } else if (IsNativeFunction(calleev, js_jam_newApply)) {
+        Value constrv = args[0];
+        if (!constrv.isObject())
+            return false;
+
+        // Refactor the stack to create a new
+        // CallArgs, and pass that to recordAction.
+        //fprintf(stderr, "Suspending due to newApply\n");
+
+        uint32_t argc = args.length();
+        if (argc == 0) {
+            // This is an error case.
+            return false;
+        }
+
+        uint32_t newargc;
+        bool isargs = false;
+        RootedObject aobj(cx);
+        if (argc > 1) {
+            isargs = args.array()[1].isMagic(JS_OPTIMIZED_ARGUMENTS);
+            if (isargs) {
+                // Conversion necessary if the second
+                // arg is the arguments object.
+                newargc = regs.fp()->numActualArgs();
+                JS_ASSERT(newargc <= ARGS_LENGTH_MAX);
+            } else {
+                aobj = &args.array()[1].toObject();
+                if (!GetLengthProperty(cx, aobj, &newargc)) {
+                    // %%% Should really go into the exception case.
+                    fprintf(stderr, "Error with GetLengthProperty in apply suspend case");
+                    return false;
+                }
+            }
+        } else {
+            newargc = 0;
+        }
+
+        // Remove the original arguments.        
+        for (uint32_t i=0; i<argc; i++) {
+            regs.sp--;
+        }
+
+        // Pop the original receiver and function.
+        regs.sp -= 2;
+        // Replace |newApply| with the function value.
+        *regs.sp++ = constrv;
+        // Push the undefined receiver.
+        regs.sp++->setUndefined();
+
+        // Push the appropriate number
+        // of undefined values so there is space
+        // for the actual arguments.
+        for (uint32_t i=0; i<newargc; i++) {
+            regs.sp++->setUndefined(); // PUSH_UNDEFINED();
+        }
+
+        if (newargc > 0) {
+            if (isargs) {
+                regs.fp()->unaliasedForEachActual(CopyTo(regs.sp - newargc));
+            } else {
+                if (!GetElements(cx, aobj, newargc, regs.sp - newargc)) {
+                    // %%% Should really go into the exception case.
+                    fprintf(stderr, "Error with GetElements in apply suspend case");
+                    return false;
+                }
+            }
+        }
+
+        // Now we can generate the new CallArgs.
+        args = CallArgsFromSp(newargc, regs.sp);
+        *construct = true;
+        return SuspendCall(cx, tx, args, construct);
+    }
+
+    // Rewrap the function value if it was undone.
+    //cx->compartment()->wrap(cx, &callee);
+    return false;
+}
+#endif
+
 bool
 js::HasInstance(JSContext *cx, HandleObject obj, HandleValue v, bool *bp)
 {
@@ -984,6 +1583,9 @@
     SuccessfulReturnContinuation,
     ErrorReturnContinuation,
     CatchContinuation,
+#ifdef TxJS
+    TxContinuation,
+#endif
     FinallyContinuation
 };
 
@@ -1043,6 +1645,17 @@
               case JSTRY_FINALLY:
                 return FinallyContinuation;
 
+#ifdef TxJS
+              // Note that the JSTRY_ITER case falls through, so this
+              // case needs to stay above that one.
+              case JSTRY_TX: {
+                // Apply the transaction handler to the speculative
+                // execution up to the point of the exception.
+                JS_ASSERT(JSOp(*regs.pc) == JSOP_END_TX);
+                return TxContinuation;
+              }
+#endif
+
               case JSTRY_ITER: {
                 /* This is similar to JSOP_ENDITER in the interpreter loop. */
                 JS_ASSERT(JSOp(*regs.pc) == JSOP_ENDITER);
@@ -1313,6 +1926,9 @@
 {
     types::TypeScript::MonitorAssign(cx, obj, id);
 
+#ifdef TxJS
+    TxContext *tx = cx->getRunningTx();
+#endif
 #ifdef JS_ION
     if (obj->isNative() && JSID_IS_INT(id)) {
         uint32_t length = obj->getDenseInitializedLength();
@@ -1328,6 +1944,17 @@
     if (obj->isNative() && !JSID_IS_INT(id) && !obj->setHadElementsAccess(cx))
         return false;
 
+#ifdef TxJS
+#ifdef TxJS_ITYPE
+    if (tx && (tx->itypes_ & AX_WRITE))
+#else
+    if (tx)
+#endif
+    {
+        tx->recordAction(cx, obj, id, value, AX_WRITE);
+        return true;
+    }
+#endif
     RootedValue tmp(cx, value);
     return JSObject::setGeneric(cx, obj, obj, id, &tmp, strict);
 }
@@ -1471,6 +2098,11 @@
     TraceLogging::defaultLogger()->log(TraceLogging::INFO_ENGINE_INTERPRETER);
 #endif
 
+#ifdef TxJS
+    // Variables used in transaction processing.
+    TxContext *tx = NULL;
+#endif
+
     /*
      * Pool of rooters for use in this interpreter frame. References to these
      * are used for local variables within interpreter cases. This avoids
@@ -1792,6 +2424,95 @@
     if (activation.entryFrame() != REGS.fp())
   inline_return:
     {
+#ifdef TxJS
+        // Resume the transaction if the frame that is returning is a
+        // transaction handler function.
+        if (REGS.fp()->suspendedTx()) {
+            
+            if (cx->compartment()->debugMode())
+                interpReturnOK = ScriptDebugEpilogue(cx, REGS.fp(), REGS.pc, interpReturnOK);
+
+            if (!REGS.fp()->isYielding())
+                REGS.fp()->epilogue(cx);
+            else
+                probes::ExitScript(cx, script, script->functionNonDelazifying(),
+                                   REGS.fp()->hasPushedSPSFrame());
+            // Unsuspend the transaction.
+            tx = REGS.fp()->suspendedTx();
+
+            // The TX_RESUME state indicates that further steps are
+            // needed before handing control back to the guest. It
+            // doesn't serve much of a purpose in the inline case, but
+            // is needed for communication in the |Invoke| case.
+            // TX_SUSPEND1|TX_END1 -> TX_RESUME|TX_DONE
+            JS_ASSERT(tx->inState(TX_SUSPEND1 | TX_END1));
+            tx->advanceState();
+            REGS.fp()->setSuspendedTx(NULL);
+
+            // Push the transaction return value before popping.
+            if (tx->inState(TX_DONE) || tx->getSuspend()->type != AX_FORIN) {
+                REGS.fp()->setReturnValue(tx->getReturnValue());
+            }
+
+            activation.popInlineFrame(REGS.fp());
+            SET_SCRIPT(REGS.fp()->script());
+
+            // Removed the JS_ASSERT on |REGS.pc| type here, since anything
+            // can potentially suspend and cause a call to the handler.
+
+            /* Resume execution in the calling frame. */
+            if (MOZ_LIKELY(interpReturnOK)) {
+                TypeScript::Monitor(cx, script, REGS.pc, REGS.sp[-1]);
+
+                if (tx->inState(TX_RESUME)) {
+                    // AX_FORIN suspends need actions after popping.
+                    if (tx->getSuspend()->type == AX_FORIN) {
+                        // Pop the Tx object off the stack.
+                        REGS.sp--;
+                        // Create the iterator.
+                        JS_ASSERT(REGS.stackDepth() >= 1);
+                        uint8_t flags = GET_UINT8(REGS.pc);
+                        MutableHandleValue res = MutableHandleValue::fromMarkedLocation(&REGS.sp[-1]);
+                        if (!ValueToIterator(cx, flags, res))
+                            goto error;
+                        JS_ASSERT(!res.isPrimitive());
+                    }
+
+                    // All necessary synchronization has occured and we can
+                    // resume the guest code.
+                    // TX_RESUME -> TX_RUNNING
+                    tx->advanceState();
+                } else {
+                    JS_ASSERT(tx->inState(TX_DONE));
+                    TxContext *doneTx = tx;
+                    tx = cx->setTxContext(tx->getNext());
+                    doneTx->finish(cx);
+                    js_free(doneTx);
+
+                    if (cx->isExceptionPending()) {
+                        // The end of a transaction within a try block
+                        // was triggered by an exception and we're now
+                        // jumping into the catch/finally.
+                        goto error;
+                    }
+                }
+
+                // In case of suspend, |op| is not JSOP_END_TX.
+                ADVANCE_AND_DISPATCH(js_CodeSpec[*REGS.pc].length);
+            }
+
+            // An exception occurred within a transaction handler.
+            // If the transaction was suspended, we need to restart
+            // it here.
+            if (tx->inState(TX_RESUME)) {
+                // TX_RESUME -> TX_RUNNING
+                JS_ASSERT(tx->inState(TX_RESUME));
+                tx->advanceState();
+            }
+            // Don't advance the pc, so JSTRY_TX can execute.
+            goto error;
+        }
+#endif
 #if JS_TRACE_LOGGING
         TraceLogging::defaultLogger()->log(TraceLogging::SCRIPT_STOP);
 #endif
@@ -1808,6 +2529,90 @@
 #if defined(JS_ION)
   jit_return_pop_frame:
 #endif
+#ifdef TxJS
+        if (REGS.fp()->suspendedTx()) {
+            // Unsuspend the transaction.
+            tx = REGS.fp()->suspendedTx();
+
+            // The TX_RESUME state indicates that further steps are
+            // needed before handing control back to the guest. It
+            // doesn't serve much of a purpose in the inline case, but
+            // is needed for communication in the |Invoke| case.
+            // TX_SUSPEND1|TX_END1 -> TX_RESUME|TX_DONE
+            JS_ASSERT(tx->inState(TX_SUSPEND1 | TX_END1));
+            tx->advanceState();
+            REGS.fp()->setSuspendedTx(NULL);
+                
+            // Push the transaction return value before popping.
+            if (tx->inState(TX_DONE) || tx->getSuspend()->type != AX_FORIN) {
+                REGS.fp()->setReturnValue(tx->getReturnValue());
+            }
+
+            activation.popInlineFrame(REGS.fp());
+            SET_SCRIPT(REGS.fp()->script());
+
+            // Removed the JS_ASSERT on |REGS.pc| type here, since anything
+            // can potentially suspend and cause a call to the handler.
+
+            /* Resume execution in the calling frame. */
+            if (MOZ_LIKELY(interpReturnOK)) {
+                TypeScript::Monitor(cx, script, REGS.pc, REGS.sp[-1]);
+
+                if (tx->inState(TX_RESUME)) {
+                    // AX_FORIN suspends need actions after popping.
+                    if (tx->getSuspend()->type == AX_FORIN) {
+                        // Pop the Tx object off the stack.
+                        REGS.sp--;
+                        // Create the iterator.
+                        JS_ASSERT(REGS.stackDepth() >= 1);
+                        uint8_t flags = GET_UINT8(REGS.pc);
+                        MutableHandleValue res = MutableHandleValue::fromMarkedLocation(&REGS.sp[-1]);
+                        if (!ValueToIterator(cx, flags, res))
+                            goto error;
+                        JS_ASSERT(!res.isPrimitive());
+                    }
+
+                    // All necessary synchronization has occured and we can
+                    // resume the guest code.
+                    // TX_RESUME -> TX_RUNNING
+                    tx->advanceState();
+                } else {
+                    JS_ASSERT(tx->inState(TX_DONE));
+                    TxContext *doneTx = tx;
+                    tx = cx->setTxContext(tx->getNext());
+                    doneTx->finish(cx);
+                    js_free(doneTx);
+                    // Pop the return value from the handler function
+                    // that is ignored.
+                    REGS.sp--;
+
+                    if (cx->isExceptionPending()) {
+                        // The end of a transaction within a try block
+                        // was triggered by an exception and we're now
+                        // jumping into the catch/finally.
+                        goto error;
+                    }
+                }
+
+                ADVANCE_AND_DISPATCH(js_CodeSpec[*REGS.pc].length);
+            }
+
+            if (tx->inState(TX_RESUME | TX_DONE)) {
+                // An exception occurred within a transaction handler.
+                // If the transaction was suspended, we need to restart
+                // it here.
+                if (tx->inState(TX_RESUME)) {
+                    // TX_RESUME -> TX_RUNNING
+                    JS_ASSERT(tx->inState(TX_RESUME));
+                    tx->advanceState();
+                }
+                // Don't advance the pc, so JSTRY_TX can execute.
+            } else
+
+            REGS.pc += JSOP_CALL_LENGTH;
+            goto error;
+        }
+#endif
 
         activation.popInlineFrame(REGS.fp());
         SET_SCRIPT(REGS.fp()->script());
@@ -1822,6 +2627,14 @@
         if (MOZ_LIKELY(interpReturnOK)) {
             TypeScript::Monitor(cx, script, REGS.pc, REGS.sp[-1]);
 
+#ifdef TxJS
+            tx = cx->getTxContext();
+            if (tx && tx->inState(TX_END1)) {
+                // Pop the return value that isn't used or expected.
+                REGS.sp--;
+                ADVANCE_AND_DISPATCH(JSOP_END_TX_LENGTH);
+            } else
+#endif
             ADVANCE_AND_DISPATCH(JSOP_CALL_LENGTH);
         }
 
@@ -1829,6 +2642,22 @@
         REGS.pc += JSOP_CALL_LENGTH;
         goto error;
     } else {
+#ifdef TxJS
+        // Resume the transaction if the frame that is returning is a
+        // transaction handler function.
+        if (REGS.fp()->suspendedTx()) {
+
+            // Unsuspend the transaction.
+            tx = REGS.fp()->suspendedTx();
+
+            // Tell the code that changes the frame pointer after the
+            // return to do any necessary processing for the suspend.
+            // TX_SUSPEND1|TX_END1 -> TX_RESUME|TX_DONE
+            JS_ASSERT(tx->inState(TX_SUSPEND1 | TX_END1));
+            tx->advanceState();
+            REGS.fp()->setSuspendedTx(NULL);
+        }
+#endif
         JS_ASSERT(REGS.stackDepth() == 0);
     }
     goto exit;
@@ -1922,6 +2751,45 @@
 CASE(JSOP_ITER)
 {
     JS_ASSERT(REGS.stackDepth() >= 1);
+#ifdef TxJS
+    // In leiu of a more robust way to coordinate iterators with
+    // speculatively written and deleted properties we suspend here
+    // to sync the transaction with the real heap.
+    tx = cx->getRunningTx();
+#if 0//def TxJS_ITYPE
+    if (tx && (tx->itypes_ & AX_MODIFY))
+#else
+    if (tx)
+#endif
+    {
+        Value val = REGS.sp[-1];
+
+        JSObject *obj;
+        if (val.isObject()) {
+            obj = &val.toObject();
+        } else {
+            if (val.isNullOrUndefined()) {
+                // |null| and |undefined| are treated as empty objects.
+                // %%% Should really check the flag.
+                obj = NewDenseEmptyArray(cx);
+            } else {
+                obj = PrimitiveToObject(cx, val);
+                if (!obj)
+                    goto error;
+            }
+        }
+
+        // %%% No real meaning; somehow get the iteration id?
+        RootedId id(cx);
+        IndexToId(cx, 0, &id);
+
+        tx->recordSuspend(cx, obj, id.get(), val, AX_FORIN);
+
+        // Leave the stack intact, since we'll carry out this operation
+        // after the suspend returns.
+        goto handle_tx;
+    }
+#endif
     uint8_t flags = GET_UINT8(REGS.pc);
     MutableHandleValue res = REGS.stackHandleAt(-1);
     if (!ValueToIterator(cx, flags, res))
@@ -2323,6 +3191,79 @@
 
     RootedObject &obj = rootObject0;
     FETCH_OBJECT(cx, -1, obj);
+#ifdef TxJS
+    tx = cx->getRunningTx();
+#ifdef TxJS_ITYPE
+    if (tx && (tx->itypes_ & AX_DELETE))
+#else
+    if (tx)
+#endif
+    {
+        jsid id = NameToId(name);
+        RootedObject &pobj = rootObject2;
+        RootedShape &prop = rootShape0;
+
+        // Retrieve the current value.
+        RootedValue &preval = rootValue0;
+        if (tx->lookupProperty(cx, obj, id, &pobj, &preval)) {
+        } else if (!JSObject::lookupProperty(cx, obj, name, &pobj, &prop)) {
+            goto error;
+        } else {
+            if (prop) {
+                //prop->get(cx, pobj, obj, pobj, &preval);
+
+                // Check for an empty-proxy case that was causing crashes.
+                // %%% This is not doing the trick. Look down inside
+                // %%% |JSObject::deleteProperty|.
+                JSObject *sobj = obj;
+                while (IsProxy(sobj)) {
+                    if (!GetProxyPrivate(sobj).isObjectOrNull()) {
+                        js_ReportIsNotDefined(cx, "Deleting property of undefined object");
+                        goto error;
+                    }
+                    sobj = GetProxyTargetObject(sobj);
+                    if (!sobj) {
+                        js_ReportIsNotDefined(cx, "Deleting property of undefined object");
+                        goto error;
+                    }
+                }
+                /*
+                RootedObject &pobj = rootObject2;
+                if (!JSObject::getProperty(cx, obj, pobj, name, &preval)) {
+                    delval.setMagic(JS_ELEMENTS_HOLE);
+                }
+                */
+
+                // Add a read to the action sequence, since deleting a
+                // property leaks the information that either
+                // 1) the property exists and is not configurable or
+                // 2) the property doesn't exist or is configurable.
+                //
+                // var o = { p1: 1 };
+                // Object.defineProperty(o, "p2", { configurable: false; });
+                // delete p1; // evaluates to |true|
+                // delete p2; // evaluates to |false|
+                // delete p9; // also evaluates to |true|
+                //
+                // %%% Use the actual value.
+                tx->recordAction(cx, obj, id, JSVAL_VOID, AX_READ);
+            }
+        }
+
+        // Add to the action sequence as a deletion.
+        MutableHandleValue res = MutableHandleValue::fromMarkedLocation(&REGS.sp[-1]);
+        if (pobj) {
+            RootedValue &delval = rootValue1;
+            delval.setMagic(JS_ELEMENTS_HOLE);
+            tx->recordAction(cx, pobj, id, delval, AX_DELETE);
+            res.setBoolean(true);
+        } else {
+            res.setBoolean(false);
+        }
+
+        END_CASE(JSOP_DELPROP)
+    }
+#endif
 
     bool succeeded;
     if (!JSObject::deleteProperty(cx, obj, name, &succeeded))
@@ -2345,6 +3286,44 @@
     RootedValue &propval = rootValue0;
     propval = REGS.sp[-1];
 
+#ifdef TxJS
+    // %%% Test this.
+    tx = cx->getRunningTx();
+#ifdef TxJS_ITYPE
+    if (tx && (tx->itypes_ && AX_DELETE))
+#else
+    if (tx)
+#endif
+    {
+        RootedId id(cx);
+        ValueToId<CanGC>(cx, propval, &id);
+
+        RootedValue &delval = rootValue0;
+        /* %%% Caused crashes on |getName|. Disabling for now.
+        if (tx->getProperty(cx, obj, id.get(), &delval)) {
+        } else {
+            RootedObject &pobj = rootObject2;
+            // %%% Shouldn't be using PropertyName/getProperty here.
+            RootedPropertyName &name = rootName0;
+            name = script->getName(REGS.pc);
+            if (!JSObject::getProperty(cx, obj, pobj, name, &delval)) {
+                // %%% Correct/needed?
+                delval = JSVAL_VOID;
+            }
+        }
+        */
+        delval.setMagic(JS_ELEMENTS_HOLE);
+        
+        // Add to the read set (per logic explained in DELPROP).
+        tx->recordAction(cx, obj, id.get(), delval, AX_READ);
+
+        // Add to the action sequence as a deletion.
+        tx->recordAction(cx, obj, id.get(), delval, AX_DELETE);
+
+        REGS.sp--;
+        END_CASE(JSOP_DELELEM)
+    }
+#endif
     bool succeeded;
     if (!JSObject::deleteByValue(cx, obj, propval, &succeeded))
         goto error;
@@ -2406,6 +3385,118 @@
 {
 
     MutableHandleValue lval = REGS.stackHandleAt(-1);
+#ifdef TxJS
+    tx = cx->getRunningTx();
+    if (tx) {
+        PropertyName *name = script->getName(REGS.pc);
+        jsid id = NameToId(name);
+        JSOp op = JSOp(*REGS.pc);
+
+        bool wasObject = lval.isObject();
+        if (op == JSOP_LENGTH && IsOptimizedArguments(REGS.fp(), lval.address())) {
+            // %%% Record read
+            lval.setInt32(REGS.fp()->numActualArgs());
+        } else {
+            RootedObject &lobj = rootObject0;
+            if (wasObject) {
+                lobj = &lval.toObject();
+            } else {
+                // Convert |lval| to an object.
+                JSObject *objp = NULL;
+                if (lval.isNullOrUndefined() || (objp = PrimitiveToObject(cx, lval)) == NULL) {
+                    js_ReportIsNullOrUndefined(cx, JSDVG_SEARCH_STACK, lval, NullPtr());
+                    goto error;
+                }
+                lobj = objp;
+            }
+                      
+            wasObject = true;
+            if (lobj->is<ArrayObject>() && name == cx->names().length) {
+                uint32_t len = tx->getArrayLength(cx, lobj);
+                lval.setNumber(len);
+            } else if (tx->getProperty(cx, lobj, id, lval)) {
+            } else {
+                // Suspend on getters.
+                bool hasGetter = false;
+                if (lobj->isNative()) {
+                    // This call is apparently only for native objects.
+                    // We use this lookup to see if we need to suspend,
+                    // so this should only apply to natives.
+                    //if (!LookupPropertyWithFlags(cx, lobj, HandleId::fromMarkedLocation(&id), cx->resolveFlags, &pobj, &shape))
+                    //    goto error;
+
+                    /* Search scopes starting with lobj and following the prototype link. */
+                    RootedObject current(cx, lobj);
+                    while (true) {
+                        Shape *shape = current->nativeLookup(cx, id);
+                        if (shape) {
+                            if (shape->hasGetterValue())
+                                hasGetter = true;
+                            break;
+                        }
+
+                        /* Try obj's class resolve hook if id was not found in obj's scope. */
+                        const Class *clasp = current->getClass();
+                        if (clasp->resolve != JS_ResolveStub) {
+                            // Check some exceptions that can bypass suspension.
+                            if (clasp == FunctionClassPtr || clasp == &StringObject::class_ || clasp == &ErrorObject::class_) {
+                                hasGetter = false;
+                            } else {
+                                hasGetter = true;
+                            }
+                            break;
+                        }
+
+                        RootedObject proto(cx, current->getProto());
+                        if (!proto)
+                            break;
+                        if (!proto->isNative()) {
+                            RootedObject &objp = rootObject1;
+                            RootedShape &propp = rootShape0;
+                            if (!JSObject::lookupGeneric(cx, proto, HandleId::fromMarkedLocation(&id), &objp, &propp))
+                                goto error;
+                            if (propp && propp->hasGetterValue())
+                                hasGetter = true;
+                            break;
+                        }
+
+                        current = proto;
+                    }
+                } else {
+                    RootedShape &shape = rootShape0;
+                    RootedObject &pobj = rootObject1;
+                    if (!JSObject::lookupProperty(cx, lobj, name, &pobj, &shape))
+                        goto error;
+                    if (shape && shape->hasGetterValue()) {
+                        hasGetter = true;
+                    }
+                }
+                if (hasGetter) {
+                    //fprintf(stderr, "Suspending due to getter\n");
+                    // The value has not been read yet, so pass
+                    // |undefined| rather than |rval|.
+                    tx->recordSuspend(cx, lobj, id, JSVAL_VOID, AX_READ);
+
+                    REGS.sp -= 1; // %%% Not sure
+                    goto handle_tx;
+                }
+
+                if (!GetPropertyOperation(cx, REGS.fp(), script, REGS.pc, lval, lval))
+                    goto error;
+            }
+            tx->recordAction(cx, lobj, id, lval.get(), AX_READ);
+#if JS_HAS_NO_SUCH_METHOD
+            if (op == JSOP_CALLPROP &&
+                MOZ_UNLIKELY(lval.isPrimitive()) &&
+                wasObject)
+            {
+                if (!OnUnknownMethod(cx, lobj, IdToValue(id), lval))
+                    goto error;
+            }
+#endif
+        }
+    } else
+#endif
     if (!GetPropertyOperation(cx, REGS.fp(), script, REGS.pc, lval, lval))
         goto error;
 
@@ -2434,6 +3525,20 @@
 
     HandleValue value = REGS.stackHandleAt(-1);
 
+#ifdef TxJS
+    tx = cx->getRunningTx();
+#ifdef TxJS_ITYPE
+    if (tx && (tx->itypes_ & AX_WRITE))
+#else
+    if (tx)
+#endif
+    {
+        RootedPropertyName name(cx, script->getName(REGS.pc));
+        RootedId &id = rootId0;
+        id = NameToId(name);
+        tx->recordAction(cx, scope, id, value.get(), AX_WRITE);
+    } else
+#endif
     if (!SetNameOperation(cx, script, REGS.pc, scope, value))
         goto error;
 
@@ -2447,6 +3552,62 @@
     HandleValue lval = REGS.stackHandleAt(-2);
     HandleValue rval = REGS.stackHandleAt(-1);
 
+#ifdef TxJS
+    tx = cx->getRunningTx();
+    if (tx) {
+        RootedObject obj(cx, ToObjectFromStack(cx, lval));
+        if (!obj)
+            goto error;
+        RootedPropertyName name(cx, script->getName(REGS.pc));
+
+        RootedShape &shape = rootShape0;
+        RootedId &id = rootId0;
+        id = NameToId(name);
+        RootedObject &pobj = rootObject1;
+        bool hasSetter = false;
+        if (obj->isNative()) {
+#ifdef TxJS_SUSPEND_NATIVE
+            hasSetter = true;
+#else
+            // This call is apparently only for native objects. We use
+            // this lookup to see if we need to suspend, so this should
+            // only apply to natives.
+            if (!LookupPropertyWithFlags(cx, obj, id, cx->resolveFlags, &pobj, &shape))
+                goto error;
+            hasSetter = shape && (shape->hasSetterValue() || !shape->hasDefaultSetter());
+#endif
+        } else {
+            if (!JSObject::lookupProperty(cx, obj, name, &pobj, &shape))
+                goto error;
+            hasSetter = shape && (shape->hasSetterValue() || !shape->hasDefaultSetter());
+        }
+        // Urrgh, the |Shape| system doesn't seem to maintain the 
+        // |suspend_| flag that is conditionally set at creation.
+        // For now, manually check for suspending property names.
+        // %%% It would be better to check the class/constructor of the
+        // %%% object also.
+        // %%% Might need to create a new table that hashes on an
+        // %%% object/property pair and stores a flag for suspend.
+        if (hasSetter)
+        {
+            // %%% This should get some intrinsic identifier for the
+            // %%% native property.
+            tx->recordSuspend(cx, obj, id, rval.get(), AX_WRITE);
+
+            REGS.sp -= 2;
+            goto handle_tx;
+        }
+#ifdef TxJS_ITYPE
+        if (tx->itypes_ & AX_WRITE) {
+#endif
+            tx->recordAction(cx, obj, id, rval.get(), AX_WRITE);
+#ifdef TxJS_ITYPE
+        } else if (!SetPropertyOperation(cx, REGS.pc, lval, rval)) {
+            goto error;
+        }
+#endif
+    } else
+#endif
     if (!SetPropertyOperation(cx, script, REGS.pc, lval, rval))
         goto error;
 
@@ -2463,6 +3624,134 @@
     MutableHandleValue res = REGS.stackHandleAt(-2);
 
     bool done = false;
+#ifdef TxJS
+    tx = cx->getRunningTx();
+#if 0//def TxJS_ITYPE
+    if (tx && (tx->itypes_ & AX_READ))
+#else
+    if (tx)
+#endif
+    {
+        if (lval.isString() && rval.isInt32()) {
+            JSString *fullstr = lval.toString();
+            JSString *charstr = NULL;
+            int32_t i = rval.toInt32();
+            if (size_t(i) < fullstr->length()) {
+                charstr = cx->runtime()->staticStrings->getUnitStringForElement(cx, fullstr, size_t(i));
+                if (!charstr)
+                    goto error;
+                res.setString(charstr);
+                RootedId id(cx);
+                IndexToId(cx, i, &id);
+                // %%% Record this
+                //tx->recordAction(cx, StringObject(fullstr), id, res.get(), AX_READ);
+                done = true;
+            }
+        }
+
+        if (!done) {
+            StackFrame *fp = REGS.fp();
+            if (IsOptimizedArguments(fp, lval.address())) {
+                if (rval.isInt32()) {
+                    int32_t i = rval.toInt32();
+                    if (i >= 0 && uint32_t(i) < fp->numActualArgs()) {
+                        res.set(fp->unaliasedActual(i));
+                        done = true;
+                    }
+                }
+
+                if (!done) {
+                    RootedScript script(cx, fp->script());
+                    if (!JSScript::argumentsOptimizationFailed(cx, script))
+                        goto error;
+
+                    lval.set(ObjectValue(fp->argsObj()));
+                    // %%% Record 
+                    //tx->recordAction(cx, StringObject(fullstr), id, res.get(), AX_READ);
+                }
+            }
+
+            if (!done) {
+                //bool isObject = lval.isObject();
+                RootedObject lobj(cx, ToObjectFromStack(cx, lval));
+                if (!lobj)
+                    goto error;
+
+                RootedId id(cx);
+                ValueToId<CanGC>(cx, rval, &id);
+                if (tx->getProperty(cx, lobj, id, res)) {
+                    done = true;
+                } else {
+                    // Suspend on getters.
+                    bool hasGetter = false;
+                    if (lobj->isNative()) {
+                        // This call is apparently only for native objects.
+                        // We use this lookup to see if we need to suspend,
+                        // so this should only apply to natives.
+                        //if (!LookupPropertyWithFlags(cx, lobj, HandleId::fromMarkedLocation(&id), cx->resolveFlags, &pobj, &shape))
+                        //    goto error;
+
+                        /* Search scopes starting with lobj and following the prototype link. */
+                        RootedObject current(cx, lobj);
+                        while (true) {
+                            Shape *shape = current->nativeLookup(cx, id);
+                            if (shape) {
+                                if (shape->hasGetterValue() || !shape->hasDefaultGetter())
+                                    hasGetter = true;
+                                break;
+                            }
+
+                            // Try obj's class resolve hook if id was not found
+                            // in obj's scope.
+                            if (current->getClass()->resolve != JS_ResolveStub) {
+                                hasGetter = true;
+                                break;
+                            }
+
+                            // Climb the prototype chain to find the property.
+                            RootedObject proto(cx, current->getProto());
+                            if (!proto)
+                                break;
+                            if (!proto->isNative()) {
+                                RootedObject &objp = rootObject1;
+                                RootedShape &propp = rootShape0;
+                                if (!JSObject::lookupGeneric(cx, proto, id, &objp, &propp))
+                                    goto error;
+                                if (propp && propp->hasGetterValue())
+                                    hasGetter = true;
+                                break;
+                            }
+
+                            current = proto;
+                        }
+                    } else {
+                        RootedShape &shape = rootShape0;
+                        RootedObject &pobj = rootObject1;
+                        if (!JSObject::lookupGeneric(cx, lobj, id, &pobj, &shape))
+                            goto error;
+                        // The typedArray.js test case demonstrates that the
+                        // IsImplicitDenseOrTypedArrayElement check is necessary.
+                        // %%% Should probably use this elsewhere.
+                        if (shape && (IsImplicitDenseOrTypedArrayElement(shape) || shape->hasGetterValue())) {
+                            hasGetter = true;
+                        }
+                    }
+                    if (hasGetter) {
+                        //fprintf(stderr, "Suspending due to getter\n");
+                        // The value has not been read yet, so pass
+                        // |undefined| rather than |rval|.
+                        tx->recordSuspend(cx, lobj, id.get(), JSVAL_VOID, AX_READ);
+
+                        REGS.sp -= 2; // %%% Not sure
+                        goto handle_tx;
+                    }
+
+                }
+            }
+        }
+    }
+    if (!done)
+#endif
     if (!GetElemOptimizedArguments(cx, REGS.fp(), lval, rval, res, &done))
         goto error;
 
@@ -2483,6 +3772,28 @@
     RootedId &id = rootId0;
     FETCH_ELEMENT_ID(-2, id);
     Value &value = REGS.sp[-1];
+#ifdef TxJS
+    tx = cx->getRunningTx();
+#ifdef TxJS_SUSPEND_NATIVE
+    if (tx && obj->isNative())
+#else
+#ifdef TxJS_ITYPE
+    if (tx && (tx->itypes_ & AX_WRITE) && obj->is<TypedArrayObject>())
+#else
+    if (tx && obj->is<TypedArrayObject>())
+#endif
+#endif
+    {
+        // Typed array objects (e.g. Int32Array) may share a buffer, so
+        // index writes must suspend.
+        // %%% Is there a way to determine if it's shared?
+        // %%% Need to suspend for ArrayBuffer also?
+        tx->recordSuspend(cx, obj, id, value, AX_WRITE);
+
+        REGS.sp -= 3;
+        goto handle_tx;
+    }
+#endif
     if (!SetObjectElementOperation(cx, obj, id, value, script->strict()))
         goto error;
     REGS.sp[-3] = value;
@@ -2493,6 +3804,18 @@
 CASE(JSOP_EVAL)
 {
     CallArgs args = CallArgsFromSp(GET_ARGC(REGS.pc), REGS.sp);
+#ifdef TxJS
+    // Suspend if within a transaction.
+    // %%% Is this right for direct and indirect eval?
+    tx = cx->getRunningTx();
+    if (tx) {
+        tx->recordSuspend(cx, &args, false);
+
+        Value *newsp = args.spAfterCall();
+        REGS.sp = newsp - 1;
+        goto handle_tx;
+    }
+#endif
     if (REGS.fp()->scopeChain()->global().valueIsEval(args.calleev())) {
         if (!DirectEval(cx, args))
             goto error;
@@ -2607,6 +3930,20 @@
 
     /* Don't bother trying to fast-path calls to scripted non-constructors. */
     if (!isFunction || !fun->isInterpretedConstructor()) {
+#ifdef TxJS
+        // Suspend on output/code generating function calls.
+        tx = cx->getRunningTx();
+        if (tx) {
+            if (SuspendCall(cx, tx, args, &construct)) {
+                // Reset the stack pointer based on the
+                // original CallArgs.
+                Value *newsp = args.spAfterCall();
+                REGS.sp = newsp - 1;
+                goto handle_tx;
+            }
+            tx->recordAction(cx, &args, construct);
+        }
+#endif
         if (construct) {
             if (!InvokeConstructor(cx, args))
                 goto error;
@@ -2662,6 +3999,13 @@
     funScript = fun->nonLazyScript();
     if (!activation.pushInlineFrame(args, funScript, initial))
         goto error;
+        
+#ifdef TxJS
+    tx = cx->getRunningTx();
+    if (tx) {
+        tx->recordAction(cx, &args, construct);
+    }
+#endif
 
     if (newType)
         REGS.fp()->setUseNewType();
@@ -2948,8 +4292,10 @@
      * method JIT, and a GETLOCAL followed by POP is not considered to be
      * a use of the variable.
      */
+#ifndef TxJS
     if (REGS.pc[JSOP_GETLOCAL_LENGTH] != JSOP_POP)
         assertSameCompartmentDebugOnly(cx, REGS.sp[-1]);
+#endif
 }
 END_CASE(JSOP_GETLOCAL)
 
@@ -2977,6 +4323,21 @@
     RootedPropertyName &name = rootName0;
     name = script->getName(REGS.pc);
 
+#ifdef TxJS
+    /*
+    tx = cx->getRunningTx();
+    if (tx) {
+        // %%% A separate case for the global object is unhandled.
+        RootedId &id = rootId0;
+        id = NameToId(name);
+        // %%% Want a new AX_DEF type?
+        tx->recordAction(cx, obj, id, JSVAL_VOID, AX_WRITE);
+
+        END_CASE(JSOP_DEFVAR)
+    }
+    */
+#endif
+
     if (!DefVarOrConstOperation(cx, obj, name, attrs))
         goto error;
 }
@@ -3063,6 +4424,9 @@
 {
     uint8_t i = GET_UINT8(REGS.pc);
     JS_ASSERT(i == JSProto_Array || i == JSProto_Object);
+#ifdef TxJS
+    tx = cx->getRunningTx();
+#endif
 
     RootedObject &obj = rootObject0;
     NewObjectKind newKind;
@@ -3158,6 +4522,17 @@
 
     if (!DefineNativeProperty(cx, obj, id, rval, nullptr, nullptr, JSPROP_ENUMERATE, 0, 0))
         goto error;
+#ifdef TxJS
+    // %%% Test this
+    tx = cx->getRunningTx();
+#ifdef TxJS_ITYPE
+    if (tx && (tx->itypes_ & AX_WRITE)) {
+#else
+    if (tx) {
+#endif
+        tx->recordAction(cx, obj, id, rval, AX_WRITE);
+    }
+#endif
 
     REGS.sp--;
 }
@@ -3172,6 +4547,23 @@
     RootedObject &obj = rootObject0;
     obj = &REGS.sp[-3].toObject();
 
+#ifdef TxJS
+    tx = cx->getRunningTx();
+#ifdef TxJS_ITYPE
+    if (tx && (tx->itypes_ & AX_WRITE)) {
+#else
+    if (tx) {
+#endif
+        // %%% Test this
+        RootedId pid(cx);
+        ValueToId<CanGC>(cx, id, &pid);
+        tx->recordAction(cx, obj, pid.get(), val, AX_WRITE);
+        REGS.sp -= 2;
+        // %%% Need to do more here?
+        END_CASE(JSOP_INITELEM)
+    }
+#endif
+
     if (!InitElemOperation(cx, obj, id, val))
         goto error;
 
@@ -3434,6 +4826,92 @@
 }
 END_CASE(JSOP_ARRAYPUSH)
 
+#ifdef TxJS
+CASE(JSOP_BEGIN_TX)
+{
+    // Get the transaction suspend/end handler.
+    // %%% Need to root?
+    Value ispect;
+    POP_COPY_TO(ispect);
+
+    if (!BeginTx(cx, ispect))
+        goto error;
+}
+END_CASE(JSOP_BEGIN_TX)
+
+CASE(JSOP_END_TX)
+{
+    // Invariant: only the innermost running/dummy transaction can end.
+    tx = cx->getClosingTx();
+    // BEGIN_TX and END_TX should always be matched.
+    JS_ASSERT(tx);
+
+#ifdef TxJS_TRANSPARENT
+    if (tx->inState(TX_DUMMY)) {
+        // Pop the current transaction context.
+        TxContext *doneTx = tx;
+        tx = cx->setTxContext(tx->getNext());
+        // A dummy transaction should never be top-level.
+        JS_ASSERT(tx != NULL);
+        doneTx->finish(cx);
+        js_free(doneTx);
+
+        // Provide a return value.
+        if (REGS.stackDepth() >= 1) {
+            // %%%  Not sure if this case (tx expression) is correct.
+            const Value &rref = REGS.sp[-1];
+            PUSH_COPY(rref);
+        } else {
+            PUSH_UNDEFINED();
+        }
+
+        ADVANCE_AND_DISPATCH(JSOP_END_TX_LENGTH);
+    }
+#endif
+    // Fall through...
+
+  // This label is also used when suspending. The suspending code must
+  // make sure that |tx| is set properly.
+  handle_tx:
+
+    int path = 0;
+    bool newType;
+    if (!IntrospectTx(cx, tx, &activation, JSOp(*REGS.pc) == JSOP_END_TX, script, &path, &newType))
+        goto error;
+
+    /* Load first op and dispatch it (safe since JSOP_STOP). */
+    if (path == 2) {
+        SET_SCRIPT(REGS.fp()->script());
+
+        if (!REGS.fp()->prologue(cx))
+            goto error;
+        if (MOZ_UNLIKELY(cx->compartment()->debugMode())) {
+            switch (ScriptDebugPrologue(cx, REGS.fp(), REGS.pc)) {
+              case JSTRAP_CONTINUE:
+                break;
+              case JSTRAP_RETURN:
+                ForcedReturn(cx, REGS);
+                goto successful_return_continuation;
+              case JSTRAP_THROW:
+              case JSTRAP_ERROR:
+                goto error;
+              default:
+                MOZ_ASSUME_UNREACHABLE("bad ScriptDebugPrologue status");
+            }
+        }
+        ADVANCE_AND_DISPATCH(0);
+    }
+    
+    // We might be handling a transaction ended by exception.
+    if (cx->isExceptionPending())
+        goto error;
+
+    // In case of suspend, |op| is not JSOP_END_TX.
+    ADVANCE_AND_DISPATCH(js_CodeSpec[*REGS.pc].length);
+}
+END_CASE(JSOP_END_TX)
+#endif
+
 DEFAULT()
 {
     char numBuf[12];
@@ -3459,6 +4937,12 @@
       case CatchContinuation:
         ADVANCE_AND_DISPATCH(0);
 
+#ifdef TxJS
+      case TxContinuation:
+        tx = cx->getClosingTx();
+        goto handle_tx;
+#endif
+
       case FinallyContinuation:
         /*
          * Push (true, exception) pair for finally to indicate that [retsub]
@@ -3477,6 +4961,38 @@
     MOZ_ASSUME_UNREACHABLE("Invalid HandleError continuation");
 
   exit:
+#ifdef TxJS
+    // Resume the transaction if the frame that is returning is a
+    // transaction handler function.
+    if (REGS.fp()->suspendedTx()) {
+        
+        // Unsuspend the transaction.
+        tx = REGS.fp()->suspendedTx();
+
+        // The TX_RESUME state indicates that further steps are
+        // needed before handing control back to the guest. It
+        // doesn't serve much of a purpose in the inline case, but
+        // is needed for communication in the |Invoke| case.
+        // TX_SUSPEND1|TX_END1 -> TX_RESUME|TX_DONE
+        JS_ASSERT(tx->inState(TX_SUSPEND1 | TX_END1));
+        tx->advanceState();
+        REGS.fp()->setSuspendedTx(NULL);
+            
+        // Push the transaction return value before popping.
+        if (tx->inState(TX_DONE) || tx->getSuspend()->type != AX_FORIN) {
+            REGS.fp()->setReturnValue(tx->getReturnValue());
+        }
+
+        // An exception occurred within a transaction handler.
+        // If the transaction was suspended, we need to restart
+        // it here.
+        if (tx->inState(TX_RESUME)) {
+            // TX_RESUME -> TX_RUNNING
+            JS_ASSERT(tx->inState(TX_RESUME));
+            tx->advanceState();
+        }
+    }
+#endif
     if (MOZ_UNLIKELY(cx->compartment()->debugMode()))
         interpReturnOK = ScriptDebugEpilogue(cx, REGS.fp(), REGS.pc, interpReturnOK);
     if (!REGS.fp()->isYielding())
@@ -3864,6 +5380,46 @@
 {
     RootedObject scope(cx), pobj(cx);
     RootedShape shape(cx);
+#ifdef TxJS
+    TxContext *tx = cx->getRunningTx();
+#ifdef TxJS_ITYPE
+    if (tx && (tx->itypes_ & AX_DELETE))
+#else
+    if (tx)
+#endif
+    {
+        RootedId id(cx, NameToId(name));
+
+        RootedValue preval(cx);
+        bool haspreval = tx->lookupName(cx, name, scopeObj, &scope, &pobj, &preval);
+        if (haspreval) {
+            // %%% Should probably record the read also.
+            res.setBoolean(true);
+        } else if (!LookupName(cx, name, scopeObj, &scope, &pobj, &shape)) {
+            return false;
+        } else {
+            if (shape) {
+                //prop->get(cx, scope, scopeObj, scope, &preval);
+                //JSObject::getProperty(cx, scopeObj, scope, name, &preval)
+                // Add to the read set since the deleting code can
+                // now tell whether the property existed.
+                tx->recordAction(cx, scopeObj, id, JSVAL_VOID, AX_READ);
+                res.setBoolean(true);
+            } else {
+                res.setBoolean(false);
+            }
+        }
+
+        if (pobj) {
+            // Add to the action sequence as a deletion.
+            RootedValue delval(cx);
+            delval.setMagic(JS_ELEMENTS_HOLE);
+            tx->recordAction(cx, scope, id, delval, AX_DELETE);
+        }
+
+        return true;
+    }
+#endif
     if (!LookupName(cx, name, scopeObj, &scope, &pobj, &shape))
         return false;
 

