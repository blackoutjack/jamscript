--- ff-orig/mozilla-31.4.0esr/js/src/vm/Interpreter.cpp	2015-01-05 23:08:07.000000000 -0600
+++ ff-dev/mozilla-31.4.0esr/js/src/vm/Interpreter.cpp	2015-02-05 12:28:02.355633898 -0600
@@ -29,6 +29,11 @@
 #include "jsprf.h"
 #include "jsscript.h"
 #include "jsstr.h"
+#ifdef TxJS
+#include "jstransaction.h"
+#include "jsjam.h"
+#include "vm/ErrorObject.h"
+#endif
 
 #include "builtin/Eval.h"
 #include "jit/BaselineJIT.h"
@@ -298,9 +303,37 @@
 
     Shape *shape = nullptr;
     JSObject *scope = nullptr, *pobj = nullptr;
+#ifdef TxJS
+    TxContext *tx = cx->getRunningTx();
+    if (tx) {
+        RootedPropertyName rootname(cx, name);
+        RootedObject rootobj(cx, obj);
+        RootedObject rootscope(cx, scope);
+        RootedObject rootpobj(cx, pobj);
+        if (tx->lookupName(cx, rootname, rootobj, &rootscope, &rootpobj, vp)) {
+            // Return the value previously assigned to the name.
+            return true;
+        }
+    }
+#endif
     if (LookupNameNoGC(cx, name, obj, &scope, &pobj, &shape)) {
         if (FetchNameNoGC(pobj, shape, vp))
+#ifdef TxJS
+        {
+            if (tx) {
+                // Add the property to the read set, with the head of the scope
+                // chain as the object, and an undefined value.
+                RootedObject rootobj(cx, obj);
+                RootedId rootid(cx, NameToId(name));
+                tx->recordAction(cx, rootobj, rootid, vp, AX_READ);
+            }
+#endif
             return true;
+#ifdef TxJS
+        }
+        // FetchName (with GC, below) is instrumented in
+        // Interpreter-inl.h.
+#endif
     }
 
     RootedObject objRoot(cx, obj), scopeRoot(cx), pobjRoot(cx);
@@ -441,8 +474,12 @@
     JS_ASSERT(args.length() <= ARGS_LENGTH_MAX);
     JS_ASSERT(!cx->compartment()->activeAnalysis);
 
+#ifdef TxJS
+    // %%% This assertion is being triggered nondeterministically.
+#else
     /* We should never enter a new script while cx->iterValue is live. */
     JS_ASSERT(cx->iterValue.isMagic(JS_NO_ITER_VALUE));
+#endif
 
     /* Perform GC if necessary on exit from the function. */
     AutoGCIfNeeded gcIfNeeded(cx);
@@ -625,6 +662,57 @@
 
     TypeScript::SetThis(cx, script, thisv);
 
+#ifdef TxJS
+    if (cx->mainThread().activation() && cx->currentlyRunningInInterpreter()) {
+        // Descend the stack to find the first dynamic introspector.
+        RootedValue ispect(cx, UndefinedValue());
+        InterpreterFrame *prevfp = cx->interpreterFrame();
+        while (ispect.isUndefined()) {
+            ispect = prevfp->script()->getIntrospector();
+            prevfp = prevfp->prev();
+            if (!prevfp) break;
+        }
+
+        if (!ispect.isUndefined()) {
+#ifdef TxJS_TRANSPARENT
+            cx->compartment()->wrap(cx, &ispect);
+            if (TxSubsumed(cx, ispect)) {
+                ispect = UndefinedValue();
+            } else {
+#endif
+                if (!BeginTx(cx, ispect))
+                    return false;
+                TxContext *tx = cx->getTxContext();
+
+                probes::StartExecution(script);
+                ExecuteState state(cx, script, thisv, scopeChainArg, type, evalInFrame, result);
+                bool ok = RunScript(cx, state);
+                probes::StopExecution(script);
+
+                if (!ok) {
+                    // Destroy the transaction in the error case.
+                    cx->setTxContext(tx->getNext());
+                    tx->finish(cx);
+                    js_free(tx);
+                    return false;
+                }
+
+                // Force non-inline execution.
+                int path = 1;
+                // Not used.
+                bool newType;
+                InterpreterActivation *act = cx->mainThread().activation()->asInterpreter();
+                if (!IntrospectTx(cx, tx, act, true, script, &path, &newType))
+                    return false;
+                JS_ASSERT(path == 1);
+                return true;
+#ifdef TxJS_TRANSPARENT
+            }
+#endif
+        }
+    }
+#endif
+
     probes::StartExecution(script);
     ExecuteState state(cx, script, thisv, scopeChainArg, type, evalInFrame, result);
     bool ok = RunScript(cx, state);
@@ -667,6 +755,518 @@
                          NullFramePtr() /* evalInFrame */, rval);
 }
 
+#ifdef TxJS
+bool
+js::BeginTx(JSContext *cx, HandleValue ispect) {
+    // Throw exception if introspector is not a function value.
+    if (!IsFunctionObject(ispect)) {
+        ReportIsNotFunction(cx, ispect, NO_CONSTRUCT);
+        return false;
+    }
+
+    // Create the tx context and place it on top of the tx stack.
+    TxContext *tx = (TxContext*)js_malloc(sizeof(TxContext));
+    TxContext::initTx(cx, tx, ispect);
+    // TX_INIT -> TX_RUNNING
+    JS_ASSERT(tx->inState(TX_INIT));
+#ifdef TxJS_TRANSPARENT
+    // Noop if a transaction with the same introspector is active.
+    bool transparent = TxSubsumed(cx, ispect);
+    if (transparent) {
+        tx->setState(TX_DUMMY);
+    } else {
+#endif
+        tx->advanceState();
+#ifdef TxJS_TRANSPARENT
+    }
+#endif
+
+    tx = cx->setTxContext(tx);
+#ifdef TxJS_PROFILE_TX
+    js_jam_profileTxEntry(cx, tx);
+#endif
+
+    return true;
+}
+
+bool
+js::IntrospectTx(JSContext *cx, TxContext *tx, InterpreterActivation *activation, bool isEnd, HandleScript script, int *path, bool *newType) {
+    JS_ASSERT(tx->inState(TX_RUNNING));
+
+    InterpreterRegs &regs = activation->regs();
+
+    if (isEnd) {
+        // Short-circuit empty transactions.
+        if (tx->getSequenceSize() == 0) {
+            // Pop the current transaction context.
+            TxContext *doneTx = tx;
+            tx = cx->setTxContext(tx->getNext());
+
+            // Push the return value.
+            RootedValue rval(cx);
+            doneTx->getReturnValue(&rval);
+            do { *regs.sp++ = rval; assertSameCompartmentDebugOnly(cx, regs.sp[-1]); } while (0);
+
+            doneTx->finish(cx);
+            js_free(doneTx);
+            
+            *path = 1;
+            return true;
+        }
+#ifdef TxJS_PROFILE_TX
+        js_jam_profileTxEnding(cx, tx);
+#endif
+#ifdef TxJS_PROFILE_ACTIONS
+        js_jam_profileActions(cx, tx);
+#endif
+        tx->setState(TX_ENDING);
+    } else {
+#ifdef TxJS_PROFILE_TX
+        js_jam_profileTxSuspension(cx, tx);
+#endif
+#ifdef TxJS_PROFILE_ACTIONS
+        js_jam_profileActions(cx, tx);
+#endif
+        tx->setState(TX_SUSPENDING);
+    }
+
+    RootedValue ispect(cx);
+    tx->getIntrospector(&ispect);
+    // BEGIN_TX should ensure this and throw an exception otherwise.
+    JS_ASSERT(IsFunctionObject(ispect));
+    cx->compartment()->wrap(cx, &ispect);
+    // Push the handler value, mimicking PUSH_COPY.
+    do { *regs.sp++ = ispect; assertSameCompartmentDebugOnly(cx, regs.sp[-1]); } while (0);
+
+    // Push an undefined value, mimicking PUSH_UNDEFINED.
+    regs.sp++->setUndefined();
+
+    // With lazy class instantiation, the call to |js_NewTxObject| may
+    // trigger a clearing of the exception (for some reason). So we note
+    // it here and restore it afterwards.
+    bool restoreExc = cx->isExceptionPending();
+    RootedValue exc(cx);
+    if (restoreExc) {
+        if (!cx->getPendingException(&exc))
+            return false;
+    }
+    // Make a Tx object and push it as the arg, mimicking PUSH_OBJECT.
+    JSObject *txobj = js_NewTxObject(cx, tx);
+    RootedValue txval(cx, ObjectValue(*txobj));
+    if (restoreExc) {
+        cx->setPendingException(exc);
+    }
+    do { *regs.sp++ = txval; assertSameCompartmentDebugOnly(cx, regs.sp[-1]); } while (0);
+
+    // Invoke the handler function.
+
+    // TX_SUSPENDING|TX_ENDING -> TX_SUSPEND0|TX_END0
+    JS_ASSERT(tx->inState(TX_SUSPENDING | TX_ENDING));
+    tx->advanceState();
+
+    if (regs.fp()->hasPushedSPSFrame())
+        cx->runtime()->spsProfiler.updatePC(script, regs.pc);
+    JS_ASSERT(regs.stackDepth() >= 3);
+    CallArgs args = CallArgsFromSp(1, regs.sp);
+
+    RootedFunction fun(cx);
+    RootedScript funScript(cx);
+    bool isFunction = IsFunctionObject(args.calleev(), fun.address());
+
+    /*
+     * Some builtins are marked as clone-at-callsite to increase precision of
+     * TI and JITs.
+     */
+    if (isFunction && fun->isInterpreted()) {
+        funScript = fun->getOrCreateScript(cx);
+        if (!funScript)
+            return false;
+        if (funScript->shouldCloneAtCallsite()) {
+            fun = CloneFunctionAtCallsite(cx, fun, script, regs.pc);
+            if (!fun)
+                return false;
+            args.setCallee(ObjectValue(*fun));
+        }
+    }
+
+    /* Don't bother trying to fast-path calls to scripted non-constructors. */
+    if (*path == 1 || !isFunction || !fun->isInterpretedConstructor()) {
+        if (!Invoke(cx, args))
+            return false;
+        Value *newsp = args.spAfterCall();
+        TypeScript::Monitor(cx, script, regs.pc, newsp[-1]);
+        regs.sp = newsp;
+            
+        if (tx->inState(TX_END0 | TX_SUSPEND0)) {
+            // This means that a native function was used as the 
+            // transaction handler, so execution doesn't go through
+            // JSOP_STOP. So we need to advance the transaction state
+            // twice.
+
+            // TX_END0|TX_SUSPEND0 -> TX_END1|TX_SUSPEND1
+            JS_ASSERT(tx->inState(TX_END0 | TX_SUSPEND0));
+            tx->advanceState();
+        }
+
+        if (tx->inState(TX_END1 | TX_SUSPEND1)) {
+            // TX_END1|TX_SUSPEND1 -> TX_DONE|TX_RESUME
+            JS_ASSERT(tx->inState(TX_END1 | TX_SUSPEND1));
+            tx->advanceState();
+        }
+
+        JS_ASSERT(tx->inState(TX_RESUME | TX_DONE));
+        if (tx->inState(TX_RESUME)) {
+            // This serves the purpose of both the |type| conditionals
+            // in JSOP_STOP in setting or suppressing the return value
+            // of the call.
+            if (tx->getSuspend()->type == AX_FORIN) {
+                // Pop the top value which is not used.
+                regs.sp--;
+                JS_ASSERT(regs.stackDepth() >= 1);
+                // Create the iterator.
+                uint8_t flags = GET_UINT8(regs.pc);
+                MutableHandleValue res = MutableHandleValue::fromMarkedLocation(&regs.sp[-1]);
+                if (!ValueToIterator(cx, flags, res))
+                    return false;
+                JS_ASSERT(!res.isPrimitive());
+            } else {
+                // Cases AX_READ, AX_CALL, AX_DELETE, AX_WRITE.
+                // Write the tx's return value to the stack.
+                JS_ASSERT(regs.stackDepth() >= 1);
+                MutableHandleValue rval = regs.stackHandleAt(-1);
+                tx->getReturnValue(rval);
+            }
+
+            // TX_RESUME -> TX_RUNNING
+            tx->advanceState();
+        } else {
+            JS_ASSERT(tx->inState(TX_DONE));
+            // Pop the current transaction context.
+            TxContext *doneTx = tx;
+            tx = cx->setTxContext(tx->getNext());
+            doneTx->finish(cx);
+            js_free(doneTx);
+
+        }
+
+        *path = 1;
+        return true;
+    }
+
+    InitialFrameFlags initial = INITIAL_NONE;
+    *newType = UseNewType(cx, script, regs.pc);
+
+    TypeMonitorCall(cx, args, false);
+
+    funScript = fun->nonLazyScript();
+    if (!activation->pushInlineFrame(args, funScript, initial))
+        return false;
+        
+    if (*newType)
+        regs.fp()->setUseNewType();
+
+    // Save a transaction that is in the process of suspending,
+    // so we can automatically resume when this frame returns.
+    JS_ASSERT(regs.fp()->suspendedTx() == NULL);
+    regs.fp()->setSuspendedTx(tx);
+
+    // TX_SUSPEND0|TX_END0 -> TX_SUSPEND1|TX_END1;
+    JS_ASSERT(tx->inState(TX_SUSPEND0 | TX_END0));
+    tx->advanceState();
+
+    *path = 2;
+    return true;
+}
+
+bool
+js::TxSubsumed(JSContext *cx, HandleValue ispect)
+{
+    TxContext *curtx = cx->getRunningTx();
+    if (curtx != NULL) {
+        RootedObject ispectObj(cx, &ispect.toObject());
+        RootedValue subsumer(cx);
+        bool checkSubsume = JSObject::getProperty(cx, ispectObj, ispectObj, cx->names().subsumedBy, &subsumer);
+        while (curtx != NULL) {
+            RootedValue curIspect(cx);
+            curtx->getIntrospector(&curIspect);
+            if (curIspect == ispect || (checkSubsume && curIspect == subsumer)) {
+                return true;
+            }
+            curtx = curtx->getNext();
+        }
+    }
+    return false;
+}
+
+bool
+js::SuspendCall(JSContext *cx, TxContext *tx, InterpreterActivation &activation, CallArgs &args, bool *construct)
+{
+    InterpreterRegs &regs = activation.regs();
+
+    // Suspend transactions on native function calls.
+    Value calleev = args.calleev();
+    if (!calleev.isObject())
+        return false;
+
+    // Strip any proxy objects.
+    JSObject *callee = &calleev.toObject();
+    while (IsProxy(callee)) {
+        calleev = GetProxyPrivate(callee);
+        if (!calleev.isObject())
+            return false;
+        callee = &calleev.toObject();
+    }
+
+    JSFunction *fun = NULL;
+    if (IsSuspendingFunction(cx, calleev, &fun)) {
+        if (fun->isBoundFunction()) {
+            JSAutoByteString bytes;
+            AtomToPrintableString(cx, fun->atom(), &bytes);
+            fprintf(stderr, "Suspending on bound function: %s\n", bytes.ptr());
+        }
+        tx->recordSuspend(cx, &args, *construct);
+        return true;
+    } else if (fun && fun->isBoundFunction()) {
+        uint32_t argc = args.length();
+
+        // Unwind bound functions.
+        JSObject *funobj = fun->getBoundFunctionTarget();
+        Value funv = ObjectValue(*funobj);
+        Value recv = fun->getBoundFunctionThis();
+        uint32_t boundargc = fun->getBoundFunctionArgumentCount();
+        uint32_t newargc = boundargc + argc;
+
+        // Pop the arguments and temporarily save.
+        Value *tmpargs = NULL;
+        if (newargc > 0)
+            tmpargs = (Value*)js_malloc(newargc * sizeof(Value));
+        for (uint32_t i=0; i<boundargc; i++) {
+            tmpargs[i] = fun->getBoundFunctionArgument(i);
+        }
+        for (uint32_t i=0; i<argc; i++) {
+            // Go from last argument to first.
+            tmpargs[newargc - 1 - i] = regs.sp[-1];
+            regs.sp--;
+        }
+
+        // Pop the receiver (presumably undefined) and the function.
+        regs.sp -= 2;
+
+        // Push the function value.
+        *regs.sp++ = funv;
+        // Push the new receiver.
+        *regs.sp++ = recv;
+
+        // Move the the receiver and arguments down one place.
+        for (uint32_t i=0; i<newargc; i++) {
+            *regs.sp++ = tmpargs[i];
+        }
+        if (newargc > 0)
+            js_free(tmpargs);
+
+        // Now we can generate the new CallArgs.
+        args = CallArgsFromSp(newargc, regs.sp);
+        return SuspendCall(cx, tx, activation, args, construct);
+    } else if (IsNativeFunction(calleev, js_fun_apply)) {
+
+        Value funv = args.thisv();
+        if (!funv.isObject())
+            return false;
+
+        // Refactor the stack to create a new
+        // CallArgs, and pass that to recordAction.
+        //fprintf(stderr, "Suspending due to apply\n");
+
+        // Hopefully this is 2: the receiver and
+        // the arguments array.
+        uint32_t argc = args.length();
+        if (argc == 0) {
+            // This is an error case.
+            return false;
+        }
+
+        uint32_t newargc;
+        bool isargs = false;
+        RootedObject aobj(cx);
+        if (argc > 1) {
+            isargs = args.array()[1].isMagic(JS_OPTIMIZED_ARGUMENTS);
+            if (isargs) {
+                // Conversion necessary if the second
+                // arg is the arguments object.
+                newargc = regs.fp()->numActualArgs();
+                JS_ASSERT(newargc <= ARGS_LENGTH_MAX);
+            } else {
+                aobj = &args.array()[1].toObject();
+                if (!GetLengthProperty(cx, aobj, &newargc)) {
+                    // %%% Should really go into the exception case.
+                    fprintf(stderr, "Error with GetLengthProperty in apply suspend case");
+                    return false;
+                }
+            }
+        } else {
+            newargc = 0;
+        }
+
+        // Remove the original arguments.        
+        for (uint32_t i=0; i<argc; i++) {
+            regs.sp--;
+        }
+
+        // Pop the original receiver and function.
+        regs.sp -= 2;
+        // Replace |newApply| with the function value.
+        *regs.sp++ = funv;
+        // Push the new receiver.
+        Value recv = args.array()[0];
+        *regs.sp++ = recv;
+             
+        // Push the appropriate number of undefined
+        // values so there is space for the arguments.
+        for (uint32_t i=0; i<newargc; i++) {
+            regs.sp++->setUndefined(); // PUSH_UNDEFINED();
+        }
+
+        // Fill the stack with the actual arguments.
+        if (newargc > 0) {
+            if (isargs) {
+                regs.fp()->unaliasedForEachActual(CopyTo(regs.sp - newargc));
+            } else {
+                if (!GetElements(cx, aobj, newargc, regs.sp - newargc)) {
+                    // %%% Should really go into the exception case.
+                    fprintf(stderr, "Error with GetElements in apply suspend case");
+                    return false;
+                }
+            }
+        }
+            
+        // Now we can generate the new CallArgs.
+        args = CallArgsFromSp(newargc, regs.sp);
+        return SuspendCall(cx, tx, activation, args, construct);
+    } else if (IsNativeFunction(calleev, js_fun_call)) {
+        Value funv = args.thisv();
+        if (!funv.isObject())
+            return false;
+
+        // Refactor the stack to create a new
+        // CallArgs, and pass that to recordAction.
+
+        // Should be > 1: a receiver and 0 or more arguments.
+        uint32_t argc = args.length();
+        if (argc == 0)
+            return false;
+
+        uint32_t newargc = argc - 1;
+
+        // Pop the arguments and temporarily save.
+        Value *tmpargs = NULL;
+        if (newargc > 0)
+            tmpargs = (Value*)js_malloc(newargc * sizeof(Value));
+        for (uint32_t i=0; i<newargc; i++) {
+            // Go from last argument to first.
+            tmpargs[newargc - 1 - i] = regs.sp[-1];
+            regs.sp--;
+        }
+        // Save the new receiver also.
+        Value recv = regs.sp[-1];
+        // Pop the new receiver, the function (old receiver),
+        // and the |call| function.
+        regs.sp -= 3;
+
+        // Push the function value.
+        *regs.sp++ = funv;
+        // Push the new receiver.
+        *regs.sp++ = recv;
+
+        // Move the the receiver and arguments down one place.
+        for (uint32_t i=0; i<newargc; i++) {
+            *regs.sp++ = tmpargs[i];
+        }
+        if (newargc > 0)
+            js_free(tmpargs);
+            
+        // Now we can generate the new CallArgs.
+        args = CallArgsFromSp(newargc, regs.sp);
+        return SuspendCall(cx, tx, activation, args, construct);
+    } else if (IsNativeFunction(calleev, js_jam_newApply)) {
+        Value constrv = args[0];
+        if (!constrv.isObject())
+            return false;
+
+        // Refactor the stack to create a new
+        // CallArgs, and pass that to recordAction.
+        //fprintf(stderr, "Suspending due to newApply\n");
+
+        uint32_t argc = args.length();
+        if (argc == 0) {
+            // This is an error case.
+            return false;
+        }
+
+        uint32_t newargc;
+        bool isargs = false;
+        RootedObject aobj(cx);
+        if (argc > 1) {
+            isargs = args.array()[1].isMagic(JS_OPTIMIZED_ARGUMENTS);
+            if (isargs) {
+                // Conversion necessary if the second
+                // arg is the arguments object.
+                newargc = regs.fp()->numActualArgs();
+                JS_ASSERT(newargc <= ARGS_LENGTH_MAX);
+            } else {
+                aobj = &args.array()[1].toObject();
+                if (!GetLengthProperty(cx, aobj, &newargc)) {
+                    // %%% Should really go into the exception case.
+                    fprintf(stderr, "Error with GetLengthProperty in apply suspend case");
+                    return false;
+                }
+            }
+        } else {
+            newargc = 0;
+        }
+
+        // Remove the original arguments.        
+        for (uint32_t i=0; i<argc; i++) {
+            regs.sp--;
+        }
+
+        // Pop the original receiver and function.
+        regs.sp -= 2;
+        // Replace |newApply| with the function value.
+        *regs.sp++ = constrv;
+        // Push the undefined receiver.
+        regs.sp++->setUndefined();
+
+        // Push the appropriate number
+        // of undefined values so there is space
+        // for the actual arguments.
+        for (uint32_t i=0; i<newargc; i++) {
+            regs.sp++->setUndefined(); // PUSH_UNDEFINED();
+        }
+
+        if (newargc > 0) {
+            if (isargs) {
+                regs.fp()->unaliasedForEachActual(CopyTo(regs.sp - newargc));
+            } else {
+                if (!GetElements(cx, aobj, newargc, regs.sp - newargc)) {
+                    // %%% Should really go into the exception case.
+                    fprintf(stderr, "Error with GetElements in apply suspend case");
+                    return false;
+                }
+            }
+        }
+
+        // Now we can generate the new CallArgs.
+        args = CallArgsFromSp(newargc, regs.sp);
+        *construct = true;
+        return SuspendCall(cx, tx, activation, args, construct);
+    }
+
+    // Rewrap the function value if it was undone.
+    //cx->compartment()->wrap(cx, &callee);
+    return false;
+}
+#endif
+
 bool
 js::HasInstance(JSContext *cx, HandleObject obj, HandleValue v, bool *bp)
 {
@@ -983,6 +1583,9 @@
     SuccessfulReturnContinuation,
     ErrorReturnContinuation,
     CatchContinuation,
+#ifdef TxJS
+    TxContinuation,
+#endif
     FinallyContinuation
 };
 
@@ -1042,6 +1645,17 @@
               case JSTRY_FINALLY:
                 return FinallyContinuation;
 
+#ifdef TxJS
+              // Note that the JSTRY_ITER case falls through, so this
+              // case needs to stay above that one.
+              case JSTRY_TX: {
+                // Apply the transaction handler to the speculative
+                // execution up to the point of the exception.
+                JS_ASSERT(JSOp(*regs.pc) == JSOP_END_TX);
+                return TxContinuation;
+              }
+#endif
+
               case JSTRY_ITER: {
                 /* This is similar to JSOP_ENDITER in the interpreter loop. */
                 JS_ASSERT(JSOp(*regs.pc) == JSOP_ENDITER);
@@ -1304,6 +1918,9 @@
 {
     types::TypeScript::MonitorAssign(cx, obj, id);
 
+#ifdef TxJS
+    TxContext *tx = cx->getRunningTx();
+#endif
 #ifdef JS_ION
     if (obj->isNative() && JSID_IS_INT(id)) {
         uint32_t length = obj->getDenseInitializedLength();
@@ -1320,6 +1937,17 @@
         return false;
 
     RootedValue tmp(cx, value);
+#ifdef TxJS
+#ifdef TxJS_ITYPE
+    if (tx && (tx->itypes_ & AX_WRITE))
+#else
+    if (tx)
+#endif
+    {
+        tx->recordAction(cx, obj, id, tmp, AX_WRITE);
+        return true;
+    }
+#endif
     return JSObject::setGeneric(cx, obj, obj, id, &tmp, strict);
 }
 
@@ -1460,6 +2088,11 @@
     TraceLogStartEvent(logger, scriptLogId);
     TraceLogStartEvent(logger, TraceLogger::Interpreter);
 
+#ifdef TxJS
+    // Variables used in transaction processing.
+    TxContext *tx = NULL;
+#endif
+
     /*
      * Pool of rooters for use in this interpreter frame. References to these
      * are used for local variables within interpreter cases. This avoids
@@ -1725,6 +2358,40 @@
 
             if (activation.entryFrame() != REGS.fp())
                 goto jit_return_pop_frame;
+#if 0//def TxJS
+            // Resume the transaction if the frame that is returning is a
+            // transaction handler function.
+            if (REGS.fp()->suspendedTx()) {
+                
+                // Unsuspend the transaction.
+                tx = REGS.fp()->suspendedTx();
+
+                // The TX_RESUME state indicates that further steps are
+                // needed before handing control back to the guest. It
+                // doesn't serve much of a purpose in the inline case, but
+                // is needed for communication in the |Invoke| case.
+                // TX_SUSPEND1|TX_END1 -> TX_RESUME|TX_DONE
+                JS_ASSERT(tx->inState(TX_SUSPEND1 | TX_END1));
+                tx->advanceState();
+                REGS.fp()->setSuspendedTx(NULL);
+                    
+                // Push the transaction return value before popping.
+                if (tx->inState(TX_DONE) || tx->getSuspend()->type != AX_FORIN) {
+                    RootedValue &rval = rootValue1;
+                    tx->getReturnValue(&rval);
+                    REGS.fp()->setReturnValue(rval);
+                }
+
+                // An exception occurred within a transaction handler.
+                // If the transaction was suspended, we need to restart
+                // it here.
+                if (tx->inState(TX_RESUME)) {
+                    // TX_RESUME -> TX_RUNNING
+                    JS_ASSERT(tx->inState(TX_RESUME));
+                    tx->advanceState();
+                }
+            }
+#endif
             goto leave_on_safe_point;
         }
     }
@@ -1796,6 +2463,97 @@
     if (activation.entryFrame() != REGS.fp())
   inline_return:
     {
+#ifdef TxJS
+        // Resume the transaction if the frame that is returning is a
+        // transaction handler function.
+        if (REGS.fp()->suspendedTx()) {
+            
+            if (cx->compartment()->debugMode())
+                interpReturnOK = ScriptDebugEpilogue(cx, REGS.fp(), REGS.pc, interpReturnOK);
+
+            if (!REGS.fp()->isYielding())
+                REGS.fp()->epilogue(cx);
+            else
+                probes::ExitScript(cx, script, script->functionNonDelazifying(),
+                                   REGS.fp()->hasPushedSPSFrame());
+            // Unsuspend the transaction.
+            tx = REGS.fp()->suspendedTx();
+
+            // The TX_RESUME state indicates that further steps are
+            // needed before handing control back to the guest. It
+            // doesn't serve much of a purpose in the inline case, but
+            // is needed for communication in the |Invoke| case.
+            // TX_SUSPEND1|TX_END1 -> TX_RESUME|TX_DONE
+            JS_ASSERT(tx->inState(TX_SUSPEND1 | TX_END1));
+            tx->advanceState();
+            REGS.fp()->setSuspendedTx(nullptr);
+
+            // Push the transaction return value before popping.
+            if (tx->inState(TX_DONE) || tx->getSuspend()->type != AX_FORIN) {
+                RootedValue &rval = rootValue1;
+                tx->getReturnValue(&rval);
+                REGS.fp()->setReturnValue(rval);
+            }
+
+            activation.popInlineFrame(REGS.fp());
+            SET_SCRIPT(REGS.fp()->script());
+
+            // Removed the JS_ASSERT on |REGS.pc| type here, since anything
+            // can potentially suspend and cause a call to the handler.
+
+            /* Resume execution in the calling frame. */
+            if (MOZ_LIKELY(interpReturnOK)) {
+                TypeScript::Monitor(cx, script, REGS.pc, REGS.sp[-1]);
+
+                if (tx->inState(TX_RESUME)) {
+                    // AX_FORIN suspends need actions after popping.
+                    if (tx->getSuspend()->type == AX_FORIN) {
+                        // Pop the Tx object off the stack.
+                        REGS.sp--;
+                        // Create the iterator.
+                        JS_ASSERT(REGS.stackDepth() >= 1);
+                        uint8_t flags = GET_UINT8(REGS.pc);
+                        MutableHandleValue res = MutableHandleValue::fromMarkedLocation(&REGS.sp[-1]);
+                        if (!ValueToIterator(cx, flags, res))
+                            goto error;
+                        JS_ASSERT(!res.isPrimitive());
+                    }
+
+                    // All necessary synchronization has occured and we can
+                    // resume the guest code.
+                    // TX_RESUME -> TX_RUNNING
+                    tx->advanceState();
+                } else {
+                    JS_ASSERT(tx->inState(TX_DONE));
+                    TxContext *doneTx = tx;
+                    tx = cx->setTxContext(tx->getNext());
+                    doneTx->finish(cx);
+                    js_free(doneTx);
+
+                    if (cx->isExceptionPending()) {
+                        // The end of a transaction within a try block
+                        // was triggered by an exception and we're now
+                        // jumping into the catch/finally.
+                        goto error;
+                    }
+                }
+
+                // In case of suspend, |op| is not JSOP_END_TX.
+                ADVANCE_AND_DISPATCH(js_CodeSpec[*REGS.pc].length);
+            }
+
+            // An exception occurred within a transaction handler.
+            // If the transaction was suspended, we need to restart
+            // it here.
+            if (tx->inState(TX_RESUME)) {
+                // TX_RESUME -> TX_RUNNING
+                JS_ASSERT(tx->inState(TX_RESUME));
+                tx->advanceState();
+            }
+            // Don't advance the pc, so JSTRY_TX can execute.
+            goto error;
+        }
+#endif
         // Stop the engine. (No details about which engine exactly, could be
         // interpreter, Baseline or IonMonkey.)
         TraceLogStopEvent(logger);
@@ -1814,6 +2572,89 @@
 #if defined(JS_ION)
   jit_return_pop_frame:
 #endif
+#ifdef TxJS
+        if (REGS.fp()->suspendedTx()) {
+            // Unsuspend the transaction.
+            tx = REGS.fp()->suspendedTx();
+
+            // The TX_RESUME state indicates that further steps are
+            // needed before handing control back to the guest. It
+            // doesn't serve much of a purpose in the inline case, but
+            // is needed for communication in the |Invoke| case.
+            // TX_SUSPEND1|TX_END1 -> TX_RESUME|TX_DONE
+            JS_ASSERT(tx->inState(TX_SUSPEND1 | TX_END1));
+            tx->advanceState();
+            REGS.fp()->setSuspendedTx(NULL);
+                
+            // Push the transaction return value before popping.
+            if (tx->inState(TX_DONE) || tx->getSuspend()->type != AX_FORIN) {
+                RootedValue &rval = rootValue1;
+                tx->getReturnValue(&rval);
+                REGS.fp()->setReturnValue(rval);
+            }
+
+            activation.popInlineFrame(REGS.fp());
+            SET_SCRIPT(REGS.fp()->script());
+
+            // Removed the JS_ASSERT on |REGS.pc| type here, since anything
+            // can potentially suspend and cause a call to the handler.
+
+            /* Resume execution in the calling frame. */
+            if (MOZ_LIKELY(interpReturnOK)) {
+                TypeScript::Monitor(cx, script, REGS.pc, REGS.sp[-1]);
+
+                if (tx->inState(TX_RESUME)) {
+                    // AX_FORIN suspends need actions after popping.
+                    if (tx->getSuspend()->type == AX_FORIN) {
+                        // Pop the Tx object off the stack.
+                        REGS.sp--;
+                        // Create the iterator.
+                        JS_ASSERT(REGS.stackDepth() >= 1);
+                        uint8_t flags = GET_UINT8(REGS.pc);
+                        MutableHandleValue res = MutableHandleValue::fromMarkedLocation(&REGS.sp[-1]);
+                        if (!ValueToIterator(cx, flags, res))
+                            goto error;
+                        JS_ASSERT(!res.isPrimitive());
+                    }
+
+                    // All necessary synchronization has occured and we can
+                    // resume the guest code.
+                    // TX_RESUME -> TX_RUNNING
+                    tx->advanceState();
+                } else {
+                    JS_ASSERT(tx->inState(TX_DONE));
+                    TxContext *doneTx = tx;
+                    tx = cx->setTxContext(tx->getNext());
+                    doneTx->finish(cx);
+                    js_free(doneTx);
+
+                    if (cx->isExceptionPending()) {
+                        // The end of a transaction within a try block
+                        // was triggered by an exception and we're now
+                        // jumping into the catch/finally.
+                        goto error;
+                    }
+                }
+
+                ADVANCE_AND_DISPATCH(js_CodeSpec[*REGS.pc].length);
+            }
+
+            if (tx->inState(TX_RESUME | TX_DONE)) {
+                // An exception occurred within a transaction handler.
+                // If the transaction was suspended, we need to restart
+                // it here.
+                if (tx->inState(TX_RESUME)) {
+                    // TX_RESUME -> TX_RUNNING
+                    JS_ASSERT(tx->inState(TX_RESUME));
+                    tx->advanceState();
+                }
+                // Don't advance the pc, so JSTRY_TX can execute.
+            } else
+
+            REGS.pc += JSOP_CALL_LENGTH;
+            goto error;
+        }
+#endif
 
         activation.popInlineFrame(REGS.fp());
         SET_SCRIPT(REGS.fp()->script());
@@ -1828,6 +2669,14 @@
         if (MOZ_LIKELY(interpReturnOK)) {
             TypeScript::Monitor(cx, script, REGS.pc, REGS.sp[-1]);
 
+#ifdef TxJS
+            tx = cx->getTxContext();
+            if (tx && tx->inState(TX_END1)) {
+                // Pop the return value that isn't used or expected.
+                REGS.sp--;
+                ADVANCE_AND_DISPATCH(JSOP_END_TX_LENGTH);
+            } else
+#endif
             ADVANCE_AND_DISPATCH(JSOP_CALL_LENGTH);
         }
 
@@ -1835,6 +2684,22 @@
         REGS.pc += JSOP_CALL_LENGTH;
         goto error;
     } else {
+#ifdef TxJS
+        // Resume the transaction if the frame that is returning is a
+        // transaction handler function.
+        if (REGS.fp()->suspendedTx()) {
+
+            // Unsuspend the transaction.
+            tx = REGS.fp()->suspendedTx();
+
+            // Tell the code that changes the frame pointer after the
+            // return to do any necessary processing for the suspend.
+            // TX_SUSPEND1|TX_END1 -> TX_RESUME|TX_DONE
+            JS_ASSERT(tx->inState(TX_SUSPEND1 | TX_END1));
+            tx->advanceState();
+            REGS.fp()->setSuspendedTx(NULL);
+        }
+#endif
         JS_ASSERT(REGS.stackDepth() == 0);
     }
     goto exit;
@@ -1930,6 +2795,43 @@
     JS_ASSERT(REGS.stackDepth() >= 1);
     uint8_t flags = GET_UINT8(REGS.pc);
     MutableHandleValue res = REGS.stackHandleAt(-1);
+#ifdef TxJS
+    // In leiu of a more robust way to coordinate iterators with
+    // speculatively written and deleted properties we suspend here
+    // to sync the transaction with the real heap.
+    tx = cx->getRunningTx();
+#if 0//def TxJS_ITYPE
+    if (tx && (tx->itypes_ & AX_MODIFY))
+#else
+    if (tx)
+#endif
+    {
+        RootedObject &obj = rootObject0;
+        if (res.isObject()) {
+            obj.set(&res.toObject());
+        } else {
+            if (res.isNullOrUndefined()) {
+                // |null| and |undefined| are treated as empty objects.
+                // %%% Should really check the flag.
+                obj.set(NewDenseEmptyArray(cx));
+            } else {
+                obj.set(PrimitiveToObject(cx, res));
+                if (!obj)
+                    goto error;
+            }
+        }
+
+        // %%% No real meaning; somehow get the iteration id?
+        RootedId id(cx);
+        IndexToId(cx, 0, &id);
+
+        tx->recordSuspend(cx, obj, id, res, AX_FORIN);
+
+        // Leave the stack intact, since we'll carry out this operation
+        // after the suspend returns.
+        goto handle_tx;
+    }
+#endif
     if (!ValueToIterator(cx, flags, res))
         goto error;
     JS_ASSERT(!res.isPrimitive());
@@ -2331,6 +3233,76 @@
     FETCH_OBJECT(cx, -1, obj);
 
     bool succeeded;
+#ifdef TxJS
+    tx = cx->getRunningTx();
+#ifdef TxJS_ITYPE
+    if (tx && (tx->itypes_ & AX_DELETE))
+#else
+    if (tx)
+#endif
+    {
+        RootedId id(cx, NameToId(name));
+        RootedObject &pobj = rootObject2;
+        RootedShape &prop = rootShape0;
+
+        // Retrieve the current value.
+        RootedValue &preval = rootValue0;
+        if (tx->lookupProperty(cx, obj, id, &pobj, &preval)) {
+        } else if (!JSObject::lookupProperty(cx, obj, name, &pobj, &prop)) {
+            goto error;
+        } else {
+            if (prop) {
+                //prop->get(cx, pobj, obj, pobj, &preval);
+
+                // Check for an empty-proxy case that was causing crashes.
+                // %%% This is not doing the trick. Look down inside
+                // %%% |JSObject::deleteProperty|.
+                while (IsProxy(obj)) {
+                    if (!GetProxyPrivate(obj).isObjectOrNull()) {
+                        js_ReportIsNotDefined(cx, "Deleting property of undefined object");
+                        goto error;
+                    }
+                    obj = GetProxyTargetObject(obj);
+                    if (!obj) {
+                        js_ReportIsNotDefined(cx, "Deleting property of undefined object");
+                        goto error;
+                    }
+                }
+                /*
+                RootedObject &pobj = rootObject2;
+                if (!JSObject::getProperty(cx, obj, pobj, name, &preval)) {
+                    delval.setMagic(JS_ELEMENTS_HOLE);
+                }
+                */
+
+                // Add a read to the action sequence, since deleting a
+                // property leaks the information that either
+                // 1) the property exists and is not configurable or
+                // 2) the property doesn't exist or is configurable.
+                //
+                // var o = { p1: 1 };
+                // Object.defineProperty(o, "p2", { configurable: false; });
+                // delete p1; // evaluates to |true|
+                // delete p2; // evaluates to |false|
+                // delete p9; // also evaluates to |true|
+                //
+                // %%% Use the actual value.
+                preval = JSVAL_VOID;
+                tx->recordAction(cx, obj, id, preval, AX_READ);
+            }
+        }
+
+        // Add to the action sequence as a deletion.
+        if (pobj) {
+            RootedValue &delval = rootValue1;
+            delval.setMagic(JS_ELEMENTS_HOLE);
+            tx->recordAction(cx, pobj, id, delval, AX_DELETE);
+            succeeded = true;
+        } else {
+            succeeded = false;
+        }
+    } else
+#endif
     if (!JSObject::deleteProperty(cx, obj, name, &succeeded))
         goto error;
     if (!succeeded && script->strict()) {
@@ -2352,6 +3324,43 @@
     propval = REGS.sp[-1];
 
     bool succeeded;
+#ifdef TxJS
+    // %%% Test this.
+    tx = cx->getRunningTx();
+#ifdef TxJS_ITYPE
+    if (tx && (tx->itypes_ && AX_DELETE))
+#else
+    if (tx)
+#endif
+    {
+        RootedId id(cx);
+        ValueToId<CanGC>(cx, propval, &id);
+
+        RootedValue &delval = rootValue0;
+        /* %%% Caused crashes on |getName|. Disabling for now.
+        if (tx->getProperty(cx, obj, id.get(), &delval)) {
+        } else {
+            RootedObject &pobj = rootObject2;
+            // %%% Shouldn't be using PropertyName/getProperty here.
+            RootedPropertyName &name = rootName0;
+            name = script->getName(REGS.pc);
+            if (!JSObject::getProperty(cx, obj, pobj, name, &delval)) {
+                // %%% Correct/needed?
+                delval = JSVAL_VOID;
+            }
+        }
+        */
+        delval.setMagic(JS_ELEMENTS_HOLE);
+        
+        // Add to the read set (per logic explained in DELPROP).
+        tx->recordAction(cx, obj, id, delval, AX_READ);
+
+        // Add to the action sequence as a deletion.
+        tx->recordAction(cx, obj, id, delval, AX_DELETE);
+        // %%% Hmmm
+        succeeded = true;
+    } else
+#endif
     if (!JSObject::deleteByValue(cx, obj, propval, &succeeded))
         goto error;
     if (!succeeded && script->strict()) {
@@ -2412,6 +3421,114 @@
 {
 
     MutableHandleValue lval = REGS.stackHandleAt(-1);
+#ifdef TxJS
+    tx = cx->getRunningTx();
+    if (tx) {
+        PropertyName *name = script->getName(REGS.pc);
+        RootedId id(cx, NameToId(name));
+        JSOp op = JSOp(*REGS.pc);
+
+        bool wasObject = lval.isObject();
+        if (op == JSOP_LENGTH && IsOptimizedArguments(REGS.fp(), lval.address())) {
+            // %%% Record read
+            lval.setInt32(REGS.fp()->numActualArgs());
+        } else {
+            RootedObject &lobj = rootObject0;
+            if (wasObject) {
+                lobj = &lval.toObject();
+            } else {
+                // Convert |lval| to an object.
+                JSObject *objp = NULL;
+                if (lval.isNullOrUndefined() || (objp = PrimitiveToObject(cx, lval)) == NULL) {
+                    js_ReportIsNullOrUndefined(cx, JSDVG_SEARCH_STACK, lval, NullPtr());
+                    goto error;
+                }
+                lobj = objp;
+            }
+                      
+            wasObject = true;
+            if (lobj->is<ArrayObject>() && name == cx->names().length) {
+                uint32_t len = tx->getArrayLength(cx, lobj);
+                lval.setNumber(len);
+            } else if (tx->getProperty(cx, lobj, id, lval)) {
+            } else {
+                // Suspend on getters.
+                bool hasGetter = false;
+                if (lobj->isNative()) {
+
+                    /* Search scopes starting with lobj and following the prototype link. */
+                    RootedObject current(cx, lobj);
+                    while (true) {
+                        Shape *shape = current->nativeLookup(cx, id);
+                        if (shape) {
+                            if (IsImplicitDenseOrTypedArrayElement(shape) || shape->hasGetterValue())
+                                hasGetter = true;
+                            break;
+                        }
+
+                        /* Try obj's class resolve hook if id was not found in obj's scope. */
+                        const Class *clasp = current->getClass();
+                        if (clasp->resolve != JS_ResolveStub) {
+                            // Check some exceptions that can bypass suspension.
+                            if (clasp == FunctionClassPtr || clasp == &StringObject::class_ || clasp == &ErrorObject::class_) {
+                                hasGetter = false;
+                            } else {
+                                hasGetter = true;
+                            }
+                            break;
+                        }
+
+                        RootedObject proto(cx, current->getProto());
+                        if (!proto)
+                            break;
+                        if (!proto->isNative()) {
+                            RootedObject &objp = rootObject1;
+                            RootedShape &propp = rootShape0;
+                            if (!JSObject::lookupGeneric(cx, proto, id, &objp, &propp))
+                                goto error;
+                            if (propp && propp->hasGetterValue())
+                                hasGetter = true;
+                            break;
+                        }
+
+                        current = proto;
+                    }
+                } else {
+                    RootedShape &shape = rootShape0;
+                    RootedObject &pobj = rootObject1;
+                    if (!JSObject::lookupProperty(cx, lobj, name, &pobj, &shape))
+                        goto error;
+                    if (shape && (IsImplicitDenseOrTypedArrayElement(shape) || shape->hasGetterValue())) {
+                        hasGetter = true;
+                    }
+                }
+                if (hasGetter) {
+                    //fprintf(stderr, "Suspending due to getter\n");
+                    // The value has not been read yet, so pass
+                    // |undefined| rather than |rval|.
+                    RootedValue val(cx, JSVAL_VOID);
+                    tx->recordSuspend(cx, lobj, id, val, AX_READ);
+
+                    REGS.sp -= 1; // %%% Not sure
+                    goto handle_tx;
+                }
+
+                if (!GetPropertyOperation(cx, REGS.fp(), script, REGS.pc, lval, lval))
+                    goto error;
+            }
+            tx->recordAction(cx, lobj, id, lval, AX_READ);
+#if JS_HAS_NO_SUCH_METHOD
+            if (op == JSOP_CALLPROP &&
+                MOZ_UNLIKELY(lval.isPrimitive()) &&
+                wasObject)
+            {
+                if (!OnUnknownMethod(cx, lobj, IdToValue(id), lval))
+                    goto error;
+            }
+#endif
+        }
+    } else
+#endif
     if (!GetPropertyOperation(cx, REGS.fp(), script, REGS.pc, lval, lval))
         goto error;
 
@@ -2440,6 +3557,19 @@
 
     HandleValue value = REGS.stackHandleAt(-1);
 
+#ifdef TxJS
+    tx = cx->getRunningTx();
+#ifdef TxJS_ITYPE
+    if (tx && (tx->itypes_ & AX_WRITE))
+#else
+    if (tx)
+#endif
+    {
+        RootedPropertyName name(cx, script->getName(REGS.pc));
+        RootedId id(cx, NameToId(name));
+        tx->recordAction(cx, scope, id, value, AX_WRITE);
+    } else
+#endif
     if (!SetNameOperation(cx, script, REGS.pc, scope, value))
         goto error;
 
@@ -2453,6 +3583,41 @@
     HandleValue lval = REGS.stackHandleAt(-2);
     HandleValue rval = REGS.stackHandleAt(-1);
 
+#ifdef TxJS
+    tx = cx->getRunningTx();
+    if (tx) {
+        RootedObject obj(cx, ToObjectFromStack(cx, lval));
+        if (!obj)
+            goto error;
+        RootedPropertyName name(cx, script->getName(REGS.pc));
+
+        RootedShape &shape = rootShape0;
+        RootedId id(cx, NameToId(name));
+        RootedObject &pobj = rootObject1;
+        if (!JSObject::lookupProperty(cx, obj, name, &pobj, &shape))
+            goto error;
+        bool hasSetter = shape && (shape->hasSetterValue() || !shape->hasDefaultSetter());
+
+        if (hasSetter)
+        {
+            // %%% This should get some intrinsic identifier for the
+            // %%% native property.
+            tx->recordSuspend(cx, obj, id, rval, AX_WRITE);
+
+            REGS.sp -= 2;
+            goto handle_tx;
+        }
+#ifdef TxJS_ITYPE
+        if (tx->itypes_ & AX_WRITE) {
+#endif
+            tx->recordAction(cx, obj, id, rval, AX_WRITE);
+#ifdef TxJS_ITYPE
+        } else if (!SetPropertyOperation(cx, REGS.pc, lval, rval)) {
+            goto error;
+        }
+#endif
+    } else
+#endif
     if (!SetPropertyOperation(cx, script, REGS.pc, lval, rval))
         goto error;
 
@@ -2469,6 +3634,130 @@
     MutableHandleValue res = REGS.stackHandleAt(-2);
 
     bool done = false;
+#ifdef TxJS
+    tx = cx->getRunningTx();
+#if 0//def TxJS_ITYPE
+    if (tx && (tx->itypes_ & AX_READ))
+#else
+    if (tx)
+#endif
+    {
+        if (lval.isString() && rval.isInt32()) {
+            JSString *fullstr = lval.toString();
+            JSString *charstr = NULL;
+            int32_t i = rval.toInt32();
+            if (size_t(i) < fullstr->length()) {
+                charstr = cx->runtime()->staticStrings->getUnitStringForElement(cx, fullstr, size_t(i));
+                if (!charstr)
+                    goto error;
+                res.setString(charstr);
+                RootedId id(cx);
+                IndexToId(cx, i, &id);
+                // %%% Record this
+                //tx->recordAction(cx, StringObject(fullstr), id, res.get(), AX_READ);
+                done = true;
+            }
+        }
+
+        if (!done) {
+            InterpreterFrame *fp = REGS.fp();
+            if (IsOptimizedArguments(fp, lval.address())) {
+                if (rval.isInt32()) {
+                    int32_t i = rval.toInt32();
+                    if (i >= 0 && uint32_t(i) < fp->numActualArgs()) {
+                        res.set(fp->unaliasedActual(i));
+                        done = true;
+                    }
+                }
+
+                if (!done) {
+                    RootedScript script(cx, fp->script());
+                    if (!JSScript::argumentsOptimizationFailed(cx, script))
+                        goto error;
+
+                    lval.set(ObjectValue(fp->argsObj()));
+                    // %%% Record 
+                    //tx->recordAction(cx, StringObject(fullstr), id, res.get(), AX_READ);
+                }
+            }
+
+            if (!done) {
+                //bool isObject = lval.isObject();
+                RootedObject lobj(cx, ToObjectFromStack(cx, lval));
+                if (!lobj)
+                    goto error;
+
+                RootedId id(cx);
+                ValueToId<CanGC>(cx, rval, &id);
+                if (tx->getProperty(cx, lobj, id, res)) {
+                    done = true;
+                } else {
+                    // Suspend on getters.
+                    bool hasGetter = false;
+                    if (lobj->isNative()) {
+
+                        /* Search scopes starting with lobj and following the prototype link. */
+                        RootedObject current(cx, lobj);
+                        while (true) {
+                            Shape *shape = current->nativeLookup(cx, id);
+                            if (shape) {
+                                if (IsImplicitDenseOrTypedArrayElement(shape) || shape->hasGetterValue() || !shape->hasDefaultGetter())
+                                    hasGetter = true;
+                                break;
+                            }
+
+                            // Try obj's class resolve hook if id was not found
+                            // in obj's scope.
+                            if (current->getClass()->resolve != JS_ResolveStub) {
+                                hasGetter = true;
+                                break;
+                            }
+
+                            // Climb the prototype chain to find the property.
+                            RootedObject proto(cx, current->getProto());
+                            if (!proto)
+                                break;
+                            if (!proto->isNative()) {
+                                RootedObject &objp = rootObject1;
+                                RootedShape &propp = rootShape0;
+                                if (!JSObject::lookupGeneric(cx, proto, id, &objp, &propp))
+                                    goto error;
+                                if (propp && propp->hasGetterValue())
+                                    hasGetter = true;
+                                break;
+                            }
+
+                            current = proto;
+                        }
+                    } else {
+                        RootedShape &shape = rootShape0;
+                        RootedObject &pobj = rootObject1;
+                        if (!JSObject::lookupGeneric(cx, lobj, id, &pobj, &shape))
+                            goto error;
+                        // The typedArray.js test case demonstrates that the
+                        // IsImplicitDenseOrTypedArrayElement check is necessary.
+                        // %%% Should probably use this elsewhere.
+                        if (shape && (IsImplicitDenseOrTypedArrayElement(shape) || shape->hasGetterValue())) {
+                            hasGetter = true;
+                        }
+                    }
+                    if (hasGetter) {
+                        //fprintf(stderr, "Suspending due to getter\n");
+                        // The value has not been read yet, so pass
+                        // |undefined| rather than |rval|.
+                        RootedValue val(cx, JSVAL_VOID);
+                        tx->recordSuspend(cx, lobj, id, val, AX_READ);
+
+                        REGS.sp -= 2; // %%% Not sure
+                        goto handle_tx;
+                    }
+
+                }
+            }
+        }
+    }
+    if (!done)
+#endif
     if (!GetElemOptimizedArguments(cx, REGS.fp(), lval, rval, res, &done))
         goto error;
 
@@ -2489,6 +3778,29 @@
     RootedId &id = rootId0;
     FETCH_ELEMENT_ID(-2, id);
     Value &value = REGS.sp[-1];
+#ifdef TxJS
+    tx = cx->getRunningTx();
+#ifdef TxJS_SUSPEND_NATIVE
+    if (tx && obj->isNative())
+#else
+#ifdef TxJS_ITYPE
+    if (tx && (tx->itypes_ & AX_WRITE) && obj->is<TypedArrayObject>())
+#else
+    if (tx && obj->is<TypedArrayObject>())
+#endif
+#endif
+    {
+        // Typed array objects (e.g. Int32Array) may share a buffer, so
+        // index writes must suspend.
+        // %%% Is there a way to determine if it's shared?
+        // %%% Need to suspend for ArrayBuffer also?
+        RootedValue val(cx, value);
+        tx->recordSuspend(cx, obj, id, val, AX_WRITE);
+
+        REGS.sp -= 3;
+        goto handle_tx;
+    }
+#endif
     if (!SetObjectElementOperation(cx, obj, id, value, script->strict()))
         goto error;
     REGS.sp[-3] = value;
@@ -2499,6 +3811,18 @@
 CASE(JSOP_EVAL)
 {
     CallArgs args = CallArgsFromSp(GET_ARGC(REGS.pc), REGS.sp);
+#ifdef TxJS
+    // Suspend if within a transaction.
+    // %%% Is this right for direct and indirect eval?
+    tx = cx->getRunningTx();
+    if (tx) {
+        tx->recordSuspend(cx, &args, false);
+
+        Value *newsp = args.spAfterCall();
+        REGS.sp = newsp - 1;
+        goto handle_tx;
+    }
+#endif
     if (REGS.fp()->scopeChain()->global().valueIsEval(args.calleev())) {
         if (!DirectEval(cx, args))
             goto error;
@@ -2613,6 +3937,20 @@
 
     /* Don't bother trying to fast-path calls to scripted non-constructors. */
     if (!isFunction || !fun->isInterpretedConstructor()) {
+#ifdef TxJS
+        // Suspend on output/code generating function calls.
+        tx = cx->getRunningTx();
+        if (tx) {
+            if (SuspendCall(cx, tx, activation, args, &construct)) {
+                // Reset the stack pointer based on the
+                // original CallArgs.
+                Value *newsp = args.spAfterCall();
+                REGS.sp = newsp - 1;
+                goto handle_tx;
+            }
+            tx->recordAction(cx, &args, construct);
+        }
+#endif
         if (construct) {
             if (!InvokeConstructor(cx, args))
                 goto error;
@@ -2668,6 +4006,13 @@
     funScript = fun->nonLazyScript();
     if (!activation.pushInlineFrame(args, funScript, initial))
         goto error;
+        
+#ifdef TxJS
+    tx = cx->getRunningTx();
+    if (tx) {
+        tx->recordAction(cx, &args, construct);
+    }
+#endif
 
     if (newType)
         REGS.fp()->setUseNewType();
@@ -2947,8 +4292,10 @@
      * method JIT, and a GETLOCAL followed by POP is not considered to be
      * a use of the variable.
      */
+#ifndef TxJS
     if (REGS.pc[JSOP_GETLOCAL_LENGTH] != JSOP_POP)
         assertSameCompartmentDebugOnly(cx, REGS.sp[-1]);
+#endif
 }
 END_CASE(JSOP_GETLOCAL)
 
@@ -3077,6 +4424,9 @@
 {
     uint8_t i = GET_UINT8(REGS.pc);
     JS_ASSERT(i == JSProto_Array || i == JSProto_Object);
+#ifdef TxJS
+    tx = cx->getRunningTx();
+#endif
 
     RootedObject &obj = rootObject0;
     NewObjectKind newKind;
@@ -3172,6 +4522,17 @@
 
     if (!DefineNativeProperty(cx, obj, id, rval, nullptr, nullptr, JSPROP_ENUMERATE))
         goto error;
+#ifdef TxJS
+    // %%% Test this
+    tx = cx->getRunningTx();
+#ifdef TxJS_ITYPE
+    if (tx && (tx->itypes_ & AX_WRITE)) {
+#else
+    if (tx) {
+#endif
+        tx->recordAction(cx, obj, id, rval, AX_WRITE);
+    }
+#endif
 
     REGS.sp--;
 }
@@ -3186,6 +4547,19 @@
     RootedObject &obj = rootObject0;
     obj = &REGS.sp[-3].toObject();
 
+#ifdef TxJS
+    tx = cx->getRunningTx();
+#ifdef TxJS_ITYPE
+    if (tx && (tx->itypes_ & AX_WRITE)) {
+#else
+    if (tx) {
+#endif
+        // %%% Test this
+        RootedId pid(cx);
+        ValueToId<CanGC>(cx, id, &pid);
+        tx->recordAction(cx, obj, pid, val, AX_WRITE);
+    } else
+#endif
     if (!InitElemOperation(cx, obj, id, val))
         goto error;
 
@@ -3448,6 +4822,96 @@
 }
 END_CASE(JSOP_ARRAYPUSH)
 
+// TxJS begin
+CASE(JSOP_BEGIN_TX)
+{
+#ifdef TxJS
+    // Get the transaction suspend/end handler.
+    // %%% Need to root?
+    RootedValue &ispect = rootValue0;
+    POP_COPY_TO(ispect);
+
+    if (!BeginTx(cx, ispect))
+        goto error;
+#endif
+}
+END_CASE(JSOP_BEGIN_TX)
+
+CASE(JSOP_END_TX)
+{
+#ifdef TxJS
+    // Invariant: only the innermost running/dummy transaction can end.
+    tx = cx->getClosingTx();
+    // BEGIN_TX and END_TX should always be matched.
+    JS_ASSERT(tx);
+
+#ifdef TxJS_TRANSPARENT
+    if (tx->inState(TX_DUMMY)) {
+        // Pop the current transaction context.
+        TxContext *doneTx = tx;
+        tx = cx->setTxContext(tx->getNext());
+        // A dummy transaction should never be top-level.
+        JS_ASSERT(tx != NULL);
+        doneTx->finish(cx);
+        js_free(doneTx);
+
+        // Provide a return value.
+        if (REGS.stackDepth() >= 1) {
+            // %%%  Not sure if this case (tx expression) is correct.
+            const Value &rref = REGS.sp[-1];
+            PUSH_COPY(rref);
+        } else {
+            PUSH_UNDEFINED();
+        }
+
+        ADVANCE_AND_DISPATCH(JSOP_END_TX_LENGTH);
+    }
+#endif
+    // Fall through...
+
+  // This label is also used when suspending. The suspending code must
+  // make sure that |tx| is set properly.
+  handle_tx:
+
+    int path = 0;
+    bool newType;
+    if (!IntrospectTx(cx, tx, &activation, JSOp(*REGS.pc) == JSOP_END_TX, script, &path, &newType))
+        goto error;
+
+    /* Load first op and dispatch it (safe since JSOP_STOP). */
+    if (path == 2) {
+        SET_SCRIPT(REGS.fp()->script());
+
+        if (!REGS.fp()->prologue(cx))
+            goto error;
+        if (MOZ_UNLIKELY(cx->compartment()->debugMode())) {
+            switch (ScriptDebugPrologue(cx, REGS.fp(), REGS.pc)) {
+              case JSTRAP_CONTINUE:
+                break;
+              case JSTRAP_RETURN:
+                ForcedReturn(cx, REGS);
+                goto successful_return_continuation;
+              case JSTRAP_THROW:
+              case JSTRAP_ERROR:
+                goto error;
+              default:
+                MOZ_ASSUME_UNREACHABLE("bad ScriptDebugPrologue status");
+            }
+        }
+        ADVANCE_AND_DISPATCH(0);
+    }
+    
+    // We might be handling a transaction ended by exception.
+    if (cx->isExceptionPending())
+        goto error;
+
+    // In case of suspend, |op| is not JSOP_END_TX.
+    ADVANCE_AND_DISPATCH(js_CodeSpec[*REGS.pc].length);
+#endif
+}
+END_CASE(JSOP_END_TX)
+// TxJS end
+
 DEFAULT()
 {
     char numBuf[12];
@@ -3473,6 +4937,12 @@
       case CatchContinuation:
         ADVANCE_AND_DISPATCH(0);
 
+#ifdef TxJS
+      case TxContinuation:
+        tx = cx->getClosingTx();
+        goto handle_tx;
+#endif
+
       case FinallyContinuation:
         /*
          * Push (true, exception) pair for finally to indicate that [retsub]
@@ -3491,6 +4961,40 @@
     MOZ_ASSUME_UNREACHABLE("Invalid HandleError continuation");
 
   exit:
+#ifdef TxJS
+    // Resume the transaction if the frame that is returning is a
+    // transaction handler function.
+    if (REGS.fp()->suspendedTx()) {
+        
+        // Unsuspend the transaction.
+        tx = REGS.fp()->suspendedTx();
+
+        // The TX_RESUME state indicates that further steps are
+        // needed before handing control back to the guest. It
+        // doesn't serve much of a purpose in the inline case, but
+        // is needed for communication in the |Invoke| case.
+        // TX_SUSPEND1|TX_END1 -> TX_RESUME|TX_DONE
+        JS_ASSERT(tx->inState(TX_SUSPEND1 | TX_END1));
+        tx->advanceState();
+        REGS.fp()->setSuspendedTx(NULL);
+            
+        // Push the transaction return value before popping.
+        if (tx->inState(TX_DONE) || tx->getSuspend()->type != AX_FORIN) {
+            RootedValue &rval = rootValue1;
+            tx->getReturnValue(&rval);
+            REGS.fp()->setReturnValue(rval);
+        }
+
+        // An exception occurred within a transaction handler.
+        // If the transaction was suspended, we need to restart
+        // it here.
+        if (tx->inState(TX_RESUME)) {
+            // TX_RESUME -> TX_RUNNING
+            JS_ASSERT(tx->inState(TX_RESUME));
+            tx->advanceState();
+        }
+    }
+#endif
     if (MOZ_UNLIKELY(cx->compartment()->debugMode()))
         interpReturnOK = ScriptDebugEpilogue(cx, REGS.fp(), REGS.pc, interpReturnOK);
     if (!REGS.fp()->isYielding())
@@ -3872,6 +5376,46 @@
 {
     RootedObject scope(cx), pobj(cx);
     RootedShape shape(cx);
+#ifdef TxJS
+    TxContext *tx = cx->getRunningTx();
+#ifdef TxJS_ITYPE
+    if (tx && (tx->itypes_ & AX_DELETE))
+#else
+    if (tx)
+#endif
+    {
+        RootedId id(cx, NameToId(name));
+        RootedValue preval(cx);
+        bool haspreval = tx->lookupName(cx, name, scopeObj, &scope, &pobj, &preval);
+        if (haspreval) {
+            // %%% Should probably record the read also.
+            res.setBoolean(true);
+        } else if (!LookupName(cx, name, scopeObj, &scope, &pobj, &shape)) {
+            return false;
+        } else {
+            if (shape) {
+                //prop->get(cx, scope, scopeObj, scope, &preval);
+                //JSObject::getProperty(cx, scopeObj, scope, name, &preval)
+                // Add to the read set since the deleting code can
+                // now tell whether the property existed.
+                RootedValue val(cx, JSVAL_VOID);
+                tx->recordAction(cx, scopeObj, id, val, AX_READ);
+                res.setBoolean(true);
+            } else {
+                res.setBoolean(false);
+            }
+        }
+
+        if (pobj) {
+            // Add to the action sequence as a deletion.
+            RootedValue delval(cx);
+            delval.setMagic(JS_ELEMENTS_HOLE);
+            tx->recordAction(cx, scope, id, delval, AX_DELETE);
+        }
+
+        return true;
+    }
+#endif
     if (!LookupName(cx, name, scopeObj, &scope, &pobj, &shape))
         return false;
 

